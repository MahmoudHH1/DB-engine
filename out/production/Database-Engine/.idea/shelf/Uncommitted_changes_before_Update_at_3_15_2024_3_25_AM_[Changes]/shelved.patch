Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"fb42b14b-88c4-43e5-8ff2-f6f11ff08115\" name=\"Changes\" comment=\"tac tac w bta3\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/DBApp.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/DBApp.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <favorite-branches>\r\n      <branch-storage>\r\n        <map>\r\n          <entry type=\"LOCAL\">\r\n            <value>\r\n              <list>\r\n                <branch-info repo=\"$PROJECT_DIR$\" source=\"Habiba\" />\r\n              </list>\r\n            </value>\r\n          </entry>\r\n        </map>\r\n      </branch-storage>\r\n    </favorite-branches>\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;mahmoudahroug&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">\r\n    <option name=\"selectedUrlAndAccountId\">\r\n      <UrlAndAccount>\r\n        <option name=\"accountId\" value=\"8c5aaf22-1b37-4541-be87-188d8703f940\" />\r\n        <option name=\"url\" value=\"https://github.com/MahmoudHH1/DB-engine.git\" />\r\n      </UrlAndAccount>\r\n    </option>\r\n  </component>\r\n  <component name=\"HighlightingSettingsPerFile\">\r\n    <setting file=\"jar://C:/Program Files (x86)/Java/jdk1.8.0_202/src.zip!/java/lang/System.java\" root0=\"SKIP_INSPECTION\" />\r\n  </component>\r\n  <component name=\"ProblemsViewState\">\r\n    <option name=\"selectedTabId\" value=\"CurrentFile\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2cmpio4uBf7MEI7A8VcnQRrZ0E8\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Application.DBApp.executor\": \"Run\",\r\n    \"Application.FileRemover.executor\": \"Run\",\r\n    \"Application.MetaData.executor\": \"Run\",\r\n    \"Application.Record.executor\": \"Run\",\r\n    \"Application.TableColumn.executor\": \"Run\",\r\n    \"Downloaded.Files.Path.Enabled\": \"false\",\r\n    \"Repository.Attach.Annotations\": \"false\",\r\n    \"Repository.Attach.JavaDocs\": \"false\",\r\n    \"Repository.Attach.Sources\": \"false\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"Saeed\",\r\n    \"kotlin-language-version-configured\": \"true\",\r\n    \"last_opened_file_path\": \"D:/Coding/DataBase/Database_projects/Database_Engine Project/Database-Engine\",\r\n    \"project.structure.last.edited\": \"Project\",\r\n    \"project.structure.proportion\": \"0.15\",\r\n    \"project.structure.side.proportion\": \"0.2\",\r\n    \"settings.editor.selected.configurable\": \"preferences.pluginManager\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Application.DBApp\">\r\n    <configuration name=\"DBApp\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"DBApp\" />\r\n      <module name=\"Database-Engine\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"FileRemover\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Data.Handler.FileRemover\" />\r\n      <module name=\"Database-Engine\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Data.Handler.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"MetaData\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Data.Table.MetaData\" />\r\n      <module name=\"Database-Engine\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Data.Table.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Table\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Data.Table.Table\" />\r\n      <module name=\"Database-Engine\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Data.Table.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"TableColumn\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Data.Table.TableColumn\" />\r\n      <module name=\"Database-Engine\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Data.Table.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\r\n      <module name=\"DB-engine\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\r\n      <module name=\"DB-engine\" />\r\n      <option name=\"filePath\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Application.FileRemover\" />\r\n      <item itemvalue=\"Application.MetaData\" />\r\n      <item itemvalue=\"Application.DBApp\" />\r\n      <item itemvalue=\"Application.Table\" />\r\n      <item itemvalue=\"Application.TableColumn\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.DBApp\" />\r\n        <item itemvalue=\"Application.TableColumn\" />\r\n        <item itemvalue=\"Application.Table\" />\r\n        <item itemvalue=\"Application.MetaData\" />\r\n        <item itemvalue=\"Application.FileRemover\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"fb42b14b-88c4-43e5-8ff2-f6f11ff08115\" name=\"Changes\" comment=\"\" />\r\n      <created>1708726737774</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1708726737774</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"unversioned files\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709135362146</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709135362146</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"solved creation error\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709159235769</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709159235769</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"solved creation error\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709159248989</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709159248989</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Splited the code into packages and i added alose getters and setters\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709178140889</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709178140889</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Splited the code into packages and i added alose getters and setters\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709178152301</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709178152301</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"modifications\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709179713674</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709179713674</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"modifications\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709180033323</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709180033323</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"modifications\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709228576040</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709228576040</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"Saeed Merge into master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709272024839</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709272024839</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"Saeed Merge into master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709272036968</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709272036968</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"Saeed Merge into master3\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709273676793</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709273676793</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"Saeed Merge into master4\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709275178465</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709275178465</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"Saeed Merge into master4\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709277618041</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709277618041</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"function kda f metadata w showaya kda f insert\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709297590066</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709297590066</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\".\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709355795543</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709355795543</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\"habiba pushed this\">\r\n      <created>1709364200815</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709364200815</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00021\" summary=\"habiba pushed this from master\">\r\n      <created>1709364507752</created>\r\n      <option name=\"number\" value=\"00021\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709364507752</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00022\" summary=\"bb\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709373510730</created>\r\n      <option name=\"number\" value=\"00022\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709373510730</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00023\" summary=\"dahroug added delete\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709374066241</created>\r\n      <option name=\"number\" value=\"00023\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709374066242</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00024\" summary=\"dahroug added delete\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709374220710</created>\r\n      <option name=\"number\" value=\"00024\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709374220710</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00025\" summary=\"saeed playing\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709374512375</created>\r\n      <option name=\"number\" value=\"00025\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709374512375</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00026\" summary=\"saeed playing on master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709378108349</created>\r\n      <option name=\"number\" value=\"00026\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709378108349</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00027\" summary=\"saeed playing on master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709378579992</created>\r\n      <option name=\"number\" value=\"00027\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709378579992</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00028\" summary=\"saeed playing on master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709379046250</created>\r\n      <option name=\"number\" value=\"00028\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709379046250</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00029\" summary=\"table idxFromName&#10;and DBApp deleteFromTable\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709380006106</created>\r\n      <option name=\"number\" value=\"00029\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709380006106</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00030\" summary=\"matching method\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709380801382</created>\r\n      <option name=\"number\" value=\"00030\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00030\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709380801382</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00031\" summary=\"shwayet basics delet keda\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709381515998</created>\r\n      <option name=\"number\" value=\"00031\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00031\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709381515998</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00032\" summary=\"table search method in progress not complete\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709385464231</created>\r\n      <option name=\"number\" value=\"00032\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709385464231</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00033\" summary=\"saeed playing on master\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709420514594</created>\r\n      <option name=\"number\" value=\"00033\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00033\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709420514594</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00034\" summary=\"saeed playing on master and he requesting for the Khalas beacause of Khalas (samaloty yaba el hag)\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709526638214</created>\r\n      <option name=\"number\" value=\"00034\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00034\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709526638214</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00035\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709529504847</created>\r\n      <option name=\"number\" value=\"00035\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00035\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709529504847</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00036\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709529516678</created>\r\n      <option name=\"number\" value=\"00036\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00036\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709529516678</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00037\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709529526173</created>\r\n      <option name=\"number\" value=\"00037\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00037\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709529526173</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00038\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709578398493</created>\r\n      <option name=\"number\" value=\"00038\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00038\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709578398493</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00039\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709589240124</created>\r\n      <option name=\"number\" value=\"00039\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00039\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709589240124</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00040\" summary=\"saeed made check for his function\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709589247615</created>\r\n      <option name=\"number\" value=\"00040\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00040\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709589247615</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00041\" summary=\"Habiba modified\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709591157305</created>\r\n      <option name=\"number\" value=\"00041\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00041\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709591157305</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00042\" summary=\"Comparable\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709726318333</created>\r\n      <option name=\"number\" value=\"00042\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00042\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709726318333</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00043\" summary=\"Made page extend vector&lt;Record&gt; to comply with grading scheme in description and refactored code\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709739801548</created>\r\n      <option name=\"number\" value=\"00043\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00043\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709739801548</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00044\" summary=\"working on binary search for clusterK key\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709741176536</created>\r\n      <option name=\"number\" value=\"00044\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00044\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709741176536</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00045\" summary=\"gamadannnnnnn\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709763580173</created>\r\n      <option name=\"number\" value=\"00045\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00045\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709763580173</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00046\" summary=\"saeed tested validator\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709852039882</created>\r\n      <option name=\"number\" value=\"00046\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00046\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709852039882</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00047\" summary=\"saeed is working on bonus\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1709901349178</created>\r\n      <option name=\"number\" value=\"00047\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00047\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1709901349178</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00048\" summary=\"insertion is done by 99.9 percent bas how meen da el tested mahmoud ya 3am enta hagebak\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710009046664</created>\r\n      <option name=\"number\" value=\"00048\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00048\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710009046664</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00049\" summary=\"kolo t7t el control&#10;done on time\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710014456039</created>\r\n      <option name=\"number\" value=\"00049\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00049\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710014456039</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00050\" summary=\"saeed added some flavors to the index and made it understandable also added some functions in TableColumn and Table related to the B+ index\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710034484128</created>\r\n      <option name=\"number\" value=\"00050\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00050\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710034484128</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00051\" summary=\"saeed added some flavors to the index\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710035345583</created>\r\n      <option name=\"number\" value=\"00051\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00051\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710035345584</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00052\" summary=\"saeed added some flavors to the index\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710061342797</created>\r\n      <option name=\"number\" value=\"00052\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00052\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710061342797</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00053\" summary=\"tac tac w bta3\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1710451292522</created>\r\n      <option name=\"number\" value=\"00053\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00053\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1710451292523</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"54\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"RECENT_FILTERS\">\r\n      <map>\r\n        <entry key=\"Branch\">\r\n          <value>\r\n            <list>\r\n              <RecentGroup>\r\n                <option name=\"FILTER_VALUES\">\r\n                  <option value=\"HEAD\" />\r\n                </option>\r\n              </RecentGroup>\r\n              <RecentGroup>\r\n                <option name=\"FILTER_VALUES\">\r\n                  <option value=\"origin/master\" />\r\n                </option>\r\n              </RecentGroup>\r\n            </list>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"User\">\r\n          <value>\r\n            <list>\r\n              <RecentGroup>\r\n                <option name=\"FILTER_VALUES\">\r\n                  <option value=\"*\" />\r\n                </option>\r\n              </RecentGroup>\r\n            </list>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"HEAD\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                  <entry key=\"user\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"*\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"function kda f metadata w showaya kda f insert\" />\r\n    <MESSAGE value=\".\" />\r\n    <MESSAGE value=\"habiba pushed this\" />\r\n    <MESSAGE value=\"habiba pushed this from master\" />\r\n    <MESSAGE value=\"bb\" />\r\n    <MESSAGE value=\"dahroug added delete\" />\r\n    <MESSAGE value=\"saeed playing\" />\r\n    <MESSAGE value=\"table idxFromName&#10;and DBApp deleteFromTable\" />\r\n    <MESSAGE value=\"matching method\" />\r\n    <MESSAGE value=\"shwayet basics delet keda\" />\r\n    <MESSAGE value=\"table search method in progress not complete\" />\r\n    <MESSAGE value=\"saeed playing on master\" />\r\n    <MESSAGE value=\"saeed playing on master and he requesting for the Khalas beacause of Khalas (samaloty yaba el hag)\" />\r\n    <MESSAGE value=\"saeed made check for his function\" />\r\n    <MESSAGE value=\"Raed did this\" />\r\n    <MESSAGE value=\"Comparable\" />\r\n    <MESSAGE value=\"Made page extend vector&lt;Record&gt; to comply with grading scheme in description and refactored code\" />\r\n    <MESSAGE value=\"working on binary search for clusterK key\" />\r\n    <MESSAGE value=\"gamadannnnnnn\" />\r\n    <MESSAGE value=\"saeed tested validator\" />\r\n    <MESSAGE value=\"insertion is done by 99.9 percent bas how meen da el tested mahmoud ya 3am enta hagebak\" />\r\n    <MESSAGE value=\"kolo t7t el control&#10;done on time\" />\r\n    <MESSAGE value=\"saeed added some flavors to the index and made it understandable also added some functions in TableColumn and Table related to the B+ index\" />\r\n    <MESSAGE value=\"saeed added some flavors to the index\" />\r\n    <MESSAGE value=\"tac tac w bta3\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"tac tac w bta3\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <breakpoint enabled=\"true\" type=\"java-exception\">\r\n          <properties class=\"Exceptions.DBAppException\" package=\"Exceptions\" />\r\n          <option name=\"timeStamp\" value=\"113\" />\r\n        </breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/Data/Table/Table.java</url>\r\n          <line>279</line>\r\n          <option name=\"timeStamp\" value=\"135\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 6822d680d4fb896fb8542aa5a48abfb30570e1d5)
+++ b/.idea/workspace.xml	(date 1710464909101)
@@ -6,7 +6,7 @@
   <component name="ChangeListManager">
     <list default="true" id="fb42b14b-88c4-43e5-8ff2-f6f11ff08115" name="Changes" comment="tac tac w bta3">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/DBApp.java" beforeDir="false" afterPath="$PROJECT_DIR$/DBApp.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Data/Index/BPlusIndex.java" beforeDir="false" afterPath="$PROJECT_DIR$/Data/Index/BPlusIndex.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -36,7 +36,7 @@
     </favorite-branches>
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="master" />
+        <entry key="$PROJECT_DIR$" value="Saeed" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -83,7 +83,7 @@
     "Repository.Attach.Sources": "false",
     "RunOnceActivity.OpenProjectViewOnStart": "true",
     "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "Saeed",
+    "git-widget-placeholder": "master",
     "kotlin-language-version-configured": "true",
     "last_opened_file_path": "D:/Coding/DataBase/Database_projects/Database_Engine Project/Database-Engine",
     "project.structure.last.edited": "Project",
@@ -197,14 +197,6 @@
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
       <updated>1708726737774</updated>
-    </task>
-    <task id="LOCAL-00005" summary="unversioned files">
-      <option name="closed" value="true" />
-      <created>1709135362146</created>
-      <option name="number" value="00005" />
-      <option name="presentableId" value="LOCAL-00005" />
-      <option name="project" value="LOCAL" />
-      <updated>1709135362146</updated>
     </task>
     <task id="LOCAL-00006" summary="solved creation error">
       <option name="closed" value="true" />
@@ -588,7 +580,15 @@
       <option name="project" value="LOCAL" />
       <updated>1710451292523</updated>
     </task>
-    <option name="localTasksCounter" value="54" />
+    <task id="LOCAL-00054" summary="tac tac w bta3">
+      <option name="closed" value="true" />
+      <created>1710460302831</created>
+      <option name="number" value="00054" />
+      <option name="presentableId" value="LOCAL-00054" />
+      <option name="project" value="LOCAL" />
+      <updated>1710460302831</updated>
+    </task>
+    <option name="localTasksCounter" value="55" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
Index: Data/Index/BPlusIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Data.Index;\r\nimport Data.Handler.FileCreator;\r\nimport org.antlr.v4.runtime.misc.Pair;\r\n//import com.sun.corba.se.impl.orbutil.ObjectWriter;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\n\r\npublic class BPlusIndex implements Serializable {\r\n    int m;\r\n    InternalNode root;\r\n    LeafNode firstLeaf;\r\n    private String tableName;\r\n    private String colName;\r\n    private String idxName ;\r\n    private String path ;\r\n    /**\r\n     * Constructor\r\n     * @param m: the order (fanout) of the B+ tree\r\n     */\r\n    public BPlusIndex(int m,String tableName,String colName , String idxName) {\r\n        this.m = m;\r\n        this.root = null;\r\n        this.tableName=tableName;\r\n        this.colName=colName;\r\n        this.idxName = idxName ;\r\n        this.path = \"Data_Entry\" + File.separator +\r\n                    \"Tables\"+ File.separator +\r\n                    tableName + File.separator+\r\n                    \"indices\"+File.separator+\r\n                    idxName;\r\n    }\r\n    public String getIndexPath(){\r\n        return this.path ;\r\n    }\r\n    public void save() throws IOException {\r\n        FileCreator.storeAsObject(this, path);\r\n    }\r\n    public String getTableName(){return tableName;}\r\n    public String getColName(){return colName;}\r\n    public String getIdxName(){return idxName;};\r\n    /*~~~~~~~~~~~~~~~~ HELPER FUNCTIONS ~~~~~~~~~~~~~~~~*/\r\n\r\n    /**\r\n     * This method performs a standard binary search on a sorted\r\n     * DictionaryPair[] and returns the index of the dictionary pair\r\n     * with target key t if found. Otherwise, this method returns a negative\r\n     * value.\r\n     * @param dps: list of dictionary pairs sorted by key within leaf node\r\n     * @param t: target key value of dictionary pair being searched for\r\n     * @return index of the target value if found, else a negative value\r\n     */\r\n    private int binarySearch(DictionaryPair[] dps, int numPairs, Object t) {\r\n        Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {\r\n            @Override\r\n            public int compare(DictionaryPair o1, DictionaryPair o2) {\r\n                return o1.compareTo(o2);\r\n            }\r\n        };\r\n        return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, \"\"), c);\r\n    }\r\n\r\n    /**\r\n     * This method starts at the root of the B+ tree and traverses down the\r\n     * tree via key comparisons to the corresponding leaf node that holds 'key'\r\n     * within its dictionary.\r\n     * @param key: the unique key that lies within the dictionary of a LeafNode object\r\n     * @return the LeafNode object that contains the key within its dictionary\r\n     */\r\n    private LeafNode findLeafNode(Object key , Object value) {\r\n        // Initialize keys and index variable\r\n        Object[] keys = this.root.keys;\r\n        Object[] values = this.root.values ;\r\n        int i;\r\n\r\n        // Find next node on path to appropriate leaf node\r\n        for (i = 0; i < this.root.degree - 1; i++) {\r\n            if (compareKeys(key, keys[i]) < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    /* Return node if it is a LeafNode object,\r\n       otherwise repeat the search function a level down */\r\n        Node child = this.root.childPointers[i];\r\n        if (child instanceof LeafNode) {\r\n            return (LeafNode) child;\r\n        } else {\r\n            return findLeafNode((InternalNode) child, key);\r\n        }\r\n    }\r\n    private LeafNode findLeafNode(InternalNode node, Object key) {\r\n        // Initialize keys and index variable\r\n        Object[] keys = node.keys;\r\n        int i;\r\n\r\n        // Find next node on path to appropriate leaf node\r\n        for (i = 0; i < node.degree - 1; i++) {\r\n            if (compareKeys(key, keys[i]) < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    /* Return node if it is a LeafNode object,\r\n       otherwise repeat the search function a level down */\r\n        Node childNode = node.childPointers[i];\r\n        if (childNode instanceof LeafNode) {\r\n            return (LeafNode) childNode;\r\n        } else {\r\n            return findLeafNode((InternalNode) childNode, key);\r\n        }\r\n    }\r\n\r\n    private int compareKeys(Object key1, Object key2) {\r\n        if (key1 instanceof Comparable && key2 instanceof Comparable) {\r\n            return ((Comparable) key1).compareTo(key2);\r\n        }\r\n        throw new IllegalArgumentException(\"Keys are not comparable.\");\r\n    }\r\n\r\n    /**\r\n     * Given a list of pointers to Node objects, this method returns the index of\r\n     * the pointer that points to the specified 'node' LeafNode object.\r\n     * @param pointers: a list of pointers to Node objects\r\n     * @param node: a specific pointer to a LeafNode\r\n     * @return (int) index of pointer in list of pointers\r\n     */\r\n    private int findIndexOfPointer(Node[] pointers, LeafNode node) {\r\n        int i;\r\n        for (i = 0; i < pointers.length; i++) {\r\n            if (pointers[i] == node) { break; }\r\n        }\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * This is a simple method that returns the midpoint (or lower bound\r\n     * depending on the context of the method invocation) of the max degree m of\r\n     * the B+ tree.\r\n     * @return (int) midpoint/lower bound\r\n     */\r\n    private int getMidpoint() {\r\n        return (int)Math.ceil((this.m + 1) / 2.0) - 1;\r\n    }\r\n\r\n    /**\r\n     * Given a deficient InternalNode in, this method remedies the deficiency\r\n     * through borrowing and merging.\r\n     * @param in: a deficient InternalNode\r\n     */\r\n    private void handleDeficiency(InternalNode in) {\r\n\r\n        InternalNode sibling;\r\n        InternalNode parent = in.parent;\r\n\r\n        // Remedy deficient root node\r\n        if (this.root == in) {\r\n            for (int i = 0; i < in.childPointers.length; i++) {\r\n                if (in.childPointers[i] != null) {\r\n                    if (in.childPointers[i] instanceof InternalNode) {\r\n                        this.root = (InternalNode)in.childPointers[i];\r\n                        this.root.parent = null;\r\n                    } else if (in.childPointers[i] instanceof LeafNode) {\r\n                        this.root = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Borrow:\r\n        else if (in.leftSibling != null && in.leftSibling.isLendable()) {\r\n            sibling = in.leftSibling;\r\n        } else if (in.rightSibling != null && in.rightSibling.isLendable()) {\r\n            sibling = in.rightSibling;\r\n\r\n            // Copy 1 key and pointer from sibling (atm just 1 key)\r\n            Object borrowedKey = sibling.keys[0];\r\n            Node pointer = sibling.childPointers[0];\r\n\r\n            // Copy root key and pointer into parent\r\n            in.keys[in.degree - 1] = parent.keys[0];\r\n            in.childPointers[in.degree] = pointer;\r\n\r\n            // Copy borrowedKey into root\r\n            parent.keys[0] = borrowedKey;\r\n\r\n            // Delete key and pointer from sibling\r\n            sibling.removePointer(0);\r\n            Arrays.sort(sibling.keys);\r\n            sibling.removePointer(0);\r\n            shiftDown(in.childPointers, 1);\r\n        }\r\n\r\n        // Merge:\r\n        else if (in.leftSibling != null && in.leftSibling.isMergeable()) {\r\n\r\n        } else if (in.rightSibling != null && in.rightSibling.isMergeable()) {\r\n            sibling = in.rightSibling;\r\n\r\n            // Copy rightmost key in parent to beginning of sibling's keys &\r\n            // delete key from parent\r\n            sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];\r\n            Arrays.sort(sibling.keys, 0, sibling.degree);\r\n            parent.keys[parent.degree - 2] = null;\r\n\r\n            // Copy in's child pointer over to sibling's list of child pointers\r\n            for (int i = 0; i < in.childPointers.length; i++) {\r\n                if (in.childPointers[i] != null) {\r\n                    sibling.prependChildPointer(in.childPointers[i]);\r\n                    in.childPointers[i].parent = sibling;\r\n                    in.removePointer(i);\r\n                }\r\n            }\r\n\r\n            // Delete child pointer from grandparent to deficient node\r\n            parent.removePointer(in);\r\n\r\n            // Remove left sibling\r\n            sibling.leftSibling = in.leftSibling;\r\n        }\r\n\r\n        // Handle deficiency a level up if it exists\r\n        if (parent != null && parent.isDeficient()) {\r\n            handleDeficiency(parent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is a simple method that determines if the B+ tree is empty or not.\r\n     * @return a boolean indicating if the B+ tree is empty or not\r\n     */\r\n    private boolean isEmpty() {\r\n        return firstLeaf == null;\r\n    }\r\n\r\n    /**\r\n     * This method performs a standard linear search on a sorted\r\n     * DictionaryPair[] and returns the index of the first null entry found.\r\n     * Otherwise, this method returns a -1. This method is primarily used in\r\n     * place of binarySearch() when the target t = null.\r\n     * @param dps: list of dictionary pairs sorted by key within leaf node\r\n     * @return index of the target value if found, else -1\r\n     */\r\n    private int linearNullSearch(DictionaryPair[] dps) {\r\n        for (int i = 0; i <  dps.length; i++) {\r\n            if (dps[i] == null) { return i; }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This method performs a standard linear search on a list of Node[] pointers\r\n     * and returns the index of the first null entry found. Otherwise, this\r\n     * method returns a -1. This method is primarily used in place of\r\n     * binarySearch() when the target t = null.\r\n     * @param pointers: list of Node[] pointers\r\n     * @return index of the target value if found, else -1\r\n     */\r\n    private int linearNullSearch(Node[] pointers) {\r\n        for (int i = 0; i <  pointers.length; i++) {\r\n            if (pointers[i] == null) { return i; }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This method is used to shift down a set of pointers that are prepended\r\n     * by null values.\r\n     * @param pointers: the list of pointers that are to be shifted\r\n     * @param amount: the amount by which the pointers are to be shifted\r\n     */\r\n    private void shiftDown(Node[] pointers, int amount) {\r\n        Node[] newPointers = new Node[this.m + 1];\r\n        for (int i = amount; i < pointers.length; i++) {\r\n            newPointers[i - amount] = pointers[i];\r\n        }\r\n        pointers = newPointers;\r\n    }\r\n\r\n    /**\r\n     * This is a specialized sorting method used upon lists of DictionaryPairs\r\n     * that may contain interspersed null values.\r\n     * @param dictionary: a list of DictionaryPair objects\r\n     */\r\n    private void sortDictionary(DictionaryPair[] dictionary) {\r\n        Arrays.sort(dictionary, new Comparator<DictionaryPair>() {\r\n            @Override\r\n            public int compare(DictionaryPair o1, DictionaryPair o2) {\r\n                if (o1 == null && o2 == null) { return 0; }\r\n                if (o1 == null) { return 1; }\r\n                if (o2 == null) { return -1; }\r\n                return o1.compareTo(o2);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This method modifies the InternalNode 'in' by removing all pointers within\r\n     * the childPointers after the specified split. The method returns the removed\r\n     * pointers in a list of their own to be used when constructing a new\r\n     * InternalNode sibling.\r\n     * @param in: an InternalNode whose childPointers will be split\r\n     * @param split: the index at which the split in the childPointers begins\r\n     * @return a Node[] of the removed pointers\r\n     */\r\n    private Node[] splitChildPointers(InternalNode in, int split) {\r\n\r\n        Node[] pointers = in.childPointers;\r\n        Node[] halfPointers = new Node[this.m + 1];\r\n\r\n        // Copy half of the values into halfPointers while updating original keys\r\n        for (int i = split + 1; i < pointers.length; i++) {\r\n            halfPointers[i - split - 1] = pointers[i];\r\n            in.removePointer(i);\r\n        }\r\n\r\n        return halfPointers;\r\n    }\r\n\r\n    /**\r\n     * This method splits a single dictionary into two dictionaries where all\r\n     * dictionaries are of equal length, but each of the resulting dictionaries\r\n     * holds half of the original dictionary's non-null values. This method is\r\n     * primarily used when splitting a node within the B+ tree. The dictionary of\r\n     * the specified LeafNode is modified in place. The method returns the\r\n     * remainder of the DictionaryPairs that are no longer within ln's dictionary.\r\n     * @param ln: list of DictionaryPairs to be split\r\n     * @param split: the index at which the split occurs\r\n     * @return DictionaryPair[] of the two split dictionaries\r\n     */\r\n    private DictionaryPair[] splitDictionary(LeafNode ln, int split) {\r\n\r\n        DictionaryPair[] dictionary = ln.dictionary;\r\n\r\n\t\t/* Initialize two dictionaries that each hold half of the original\r\n\t\t   dictionary values */\r\n        DictionaryPair[] halfDict = new DictionaryPair[this.m];\r\n\r\n        // Copy half of the values into halfDict\r\n        for (int i = split; i < dictionary.length; i++) {\r\n            halfDict[i - split] = dictionary[i];\r\n            ln.delete(i);\r\n        }\r\n\r\n        return halfDict;\r\n    }\r\n\r\n    /**\r\n     * When an insertion into the B+ tree causes an overfull node, this method\r\n     * is called to remedy the issue, i.e. to split the overfull node. This method\r\n     * calls the sub-methods of splitKeys() and splitChildPointers() in order to\r\n     * split the overfull node.\r\n     * @param in: an overfull InternalNode that is to be split\r\n     */\r\n    private void splitInternalNode(InternalNode in) {\r\n        // Acquire parent\r\n        InternalNode parent = in.parent;\r\n\r\n        // Split keys and pointers in half\r\n        int midpoint = getMidpoint();\r\n        Object newParentKey = in.keys[midpoint];\r\n        Object newParentValue = in.values[midpoint];\r\n        Object[] halfKeys = splitKeys(in.keys, midpoint);\r\n        Object[] halfValues = splitValues(in.values , midpoint);\r\n        Node[] halfPointers = splitChildPointers(in, midpoint);\r\n\r\n        // Change degree of original InternalNode in\r\n        in.degree = linearNullSearch(in.childPointers);\r\n\r\n        // Create new sibling internal node and add half of keys and pointers\r\n        InternalNode sibling = new InternalNode(this.m, halfKeys,halfValues,halfPointers);\r\n        for (Node pointer : halfPointers) {\r\n            if (pointer != null) {\r\n                pointer.parent = sibling;\r\n            }\r\n        }\r\n\r\n        // Make internal nodes siblings of one another\r\n        sibling.rightSibling = in.rightSibling;\r\n        if (sibling.rightSibling != null) {\r\n            sibling.rightSibling.leftSibling = sibling;\r\n        }\r\n        in.rightSibling = sibling;\r\n        sibling.leftSibling = in;\r\n\r\n        if (parent == null) {\r\n            // Create new root node and add midpoint key and pointers\r\n            Object[] keys = new Object[this.m];\r\n            Object[] values = new Object[this.m] ;\r\n            keys[0] = newParentKey;\r\n            InternalNode newRoot = new InternalNode(this.m, keys ,values);\r\n            newRoot.appendChildPointer(in);\r\n            newRoot.appendChildPointer(sibling);\r\n            this.root = newRoot;\r\n\r\n            // Add pointers from children to parent\r\n            in.parent = newRoot;\r\n            sibling.parent = newRoot;\r\n        } else {\r\n            // Add key to parent\r\n            parent.keys[parent.degree - 1] = newParentKey;\r\n            Arrays.sort(parent.keys, 0, parent.degree);\r\n\r\n            // Set up pointer to new sibling\r\n            int pointerIndex = parent.findIndexOfPointer(in) + 1;\r\n            parent.insertChildPointer(sibling, pointerIndex);\r\n            sibling.parent = parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method modifies a list of Integer-typed objects that represent keys\r\n     * by removing half of the keys and returning them in a separate Integer[].\r\n     * This method is used when splitting an InternalNode object.\r\n     * @param keys: a list of Integer objects\r\n     * @param split: the index where the split is to occur\r\n     * @return Integer[] of removed keys\r\n     */\r\n    private Object[] splitKeys(Object[] keys, int split) {\r\n        Object[] halfKeys = new Object[this.m];\r\n\r\n        // Remove split-indexed value from keys\r\n        keys[split] = null;\r\n\r\n        // Copy half of the values into halfKeys while updating original keys\r\n        for (int i = split + 1; i < keys.length; i++) {\r\n            halfKeys[i - split - 1] = keys[i];\r\n            keys[i] = null;\r\n        }\r\n\r\n        return halfKeys;\r\n    }\r\n    private Object[] splitValues(Object[] values, int split) {\r\n        Object[] halfValues = new Object[this.m];\r\n\r\n        // Remove split-indexed value from keys\r\n        values[split] = null;\r\n\r\n        // Copy half of the values into halfKeys while updating original keys\r\n        for (int i = split + 1; i < values.length; i++) {\r\n            halfValues[i - split - 1] = values[i];\r\n            values[i] = null;\r\n        }\r\n\r\n        return halfValues;\r\n    }\r\n\r\n\r\n    /*~~~~~~~~~~~~~~~~ API: DELETE, INSERT, SEARCH ~~~~~~~~~~~~~~~~*/\r\n\r\n    /**\r\n     * Given a key, this method will remove the dictionary pair with the\r\n     * corresponding key from the B+ tree.\r\n     * @param key: an integer key that corresponds with an existing dictionary\r\n     *             pair\r\n     */\r\n    public void delete(Object key , Object value) {\r\n        if (isEmpty()) {\r\n\r\n            /* Flow of execution goes here when B+ tree has no dictionary pairs */\r\n\r\n            System.err.println(\"Invalid Delete: The B+ tree is currently empty.\");\r\n\r\n        } else {\r\n\r\n            // Get leaf node and attempt to find index of key to delete\r\n            LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key ,value);\r\n            int dpIndex = binarySearch(ln.dictionary, ln.numPairs, key);\r\n\r\n\r\n            if (dpIndex < 0) {\r\n\r\n                /* Flow of execution goes here when key is absent in B+ tree */\r\n\r\n                System.err.println(\"Invalid Delete: Key unable to be found.\");\r\n\r\n            } else {\r\n\r\n                // Successfully delete the dictionary pair\r\n                ln.delete(dpIndex);\r\n\r\n                // Check for deficiencies\r\n                if (ln.isDeficient()) {\r\n\r\n                    LeafNode sibling;\r\n                    InternalNode parent = ln.parent;\r\n\r\n                    // Borrow: First, check the left sibling, then the right sibling\r\n                    if (ln.leftSibling != null &&\r\n                            ln.leftSibling.parent == ln.parent &&\r\n                            ln.leftSibling.isLendable()) {\r\n\r\n                        sibling = ln.leftSibling;\r\n                        DictionaryPair borrowedDP = sibling.dictionary[sibling.numPairs - 1];\r\n\r\n\t\t\t\t\t\t/* Insert borrowed dictionary pair, sort dictionary,\r\n\t\t\t\t\t\t   and delete dictionary pair from sibling */\r\n                        ln.insert(borrowedDP);\r\n                        sortDictionary(ln.dictionary);\r\n                        sibling.delete(sibling.numPairs - 1);\r\n\r\n                        // Update key in parent if necessary\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n                        if (((Comparable)borrowedDP.key).compareTo(parent.keys[pointerIndex - 1]) < 0) {\r\n                            parent.keys[pointerIndex - 1] = ln.dictionary[0].key;\r\n                        }\r\n\r\n\r\n                    } else if (ln.rightSibling != null &&\r\n                            ln.rightSibling.parent == ln.parent &&\r\n                            ln.rightSibling.isLendable()) {\r\n\r\n                        sibling = ln.rightSibling;\r\n                        DictionaryPair borrowedDP = sibling.dictionary[0];\r\n\r\n\t\t\t\t\t\t/* Insert borrowed dictionary pair, sort dictionary,\r\n\t\t\t\t\t       and delete dictionary pair from sibling */\r\n                        ln.insert(borrowedDP);\r\n                        sibling.delete(0);\r\n                        sortDictionary(sibling.dictionary);\r\n\r\n                        // Update key in parent if necessary\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n                        if (((Comparable) borrowedDP.key).compareTo(parent.keys[pointerIndex]) >= 0) {\r\n                            parent.keys[pointerIndex] = sibling.dictionary[0].key;\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                    // Merge: First, check the left sibling, then the right sibling\r\n                    else if (ln.leftSibling != null &&\r\n                            ln.leftSibling.parent == ln.parent &&\r\n                            ln.leftSibling.isMergeable()) {\r\n\r\n                        sibling = ln.leftSibling;\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n\r\n                        // Remove key and child pointer from parent\r\n                        parent.removeKey(pointerIndex - 1);\r\n                        parent.removePointer(ln);\r\n\r\n                        // Update sibling pointer\r\n                        sibling.rightSibling = ln.rightSibling;\r\n\r\n                        // Check for deficiencies in parent\r\n                        if (parent.isDeficient()) {\r\n                            handleDeficiency(parent);\r\n                        }\r\n\r\n                    } else if (ln.rightSibling != null &&\r\n                            ln.rightSibling.parent == ln.parent &&\r\n                            ln.rightSibling.isMergeable()) {\r\n\r\n                        sibling = ln.rightSibling;\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n\r\n                        // Remove key and child pointer from parent\r\n                        parent.removeKey(pointerIndex);\r\n                        parent.removePointer(pointerIndex);\r\n\r\n                        // Update sibling pointer\r\n                        sibling.leftSibling = ln.leftSibling;\r\n                        if (sibling.leftSibling == null) {\r\n                            firstLeaf = sibling;\r\n                        }\r\n\r\n                        if (parent.isDeficient()) {\r\n                            handleDeficiency(parent);\r\n                        }\r\n                    }\r\n\r\n                } else if (this.root == null && this.firstLeaf.numPairs == 0) {\r\n\r\n\t\t\t\t\t/* Flow of execution goes here when the deleted dictionary\r\n\t\t\t\t\t   pair was the only pair within the tree */\r\n\r\n                    // Set first leaf as null to indicate B+ tree is empty\r\n                    this.firstLeaf = null;\r\n\r\n                } else {\r\n\r\n\t\t\t\t\t/* The dictionary of the LeafNode object may need to be\r\n\t\t\t\t\t   sorted after a successful delete */\r\n                    sortDictionary(ln.dictionary);\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given an integer key and floating point value, this method inserts a\r\n     * dictionary pair accordingly into the B+ tree.\r\n     * @param key: an integer key to be used in the dictionary pair\r\n     * @param value: a floating point number to be used in the dictionary pair\r\n     */\r\n    //    B+\r\n    // id age\r\n    // 1  20\r\n    // 2  50\r\n    // insert id =3 , age=60          // B+  key:60  , value:3      node( value , refrence)\r\n    // cluster\r\n    // btree.toString()\r\n\r\n    public void insert(Object key, Object value){\r\n        if (isEmpty()) {\r\n\r\n            /* Flow of execution goes here only when first insert takes place */\r\n\r\n            // Create leaf node as first node in B plus tree (root is null)\r\n            LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));\r\n\r\n            // Set as first leaf node (can be used later for in-order leaf traversal)\r\n            this.firstLeaf = ln;\r\n\r\n        } else {\r\n            // Find leaf node to insert into\r\n            LeafNode ln = (this.root == null) ? this.firstLeaf :\r\n                    findLeafNode(key);\r\n\r\n            // Insert into leaf node fails if node becomes overfull\r\n            if (!ln.insert(new DictionaryPair(key, value))) {\r\n\r\n                // Sort all the dictionary pairs with the included pair to be inserted\r\n                ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);\r\n                ln.numPairs++;\r\n                sortDictionary(ln.dictionary);\r\n\r\n                // Split the sorted pairs into two halves\r\n                int midpoint = getMidpoint();\r\n                DictionaryPair[] halfDict = splitDictionary(ln, midpoint);\r\n\r\n                if (ln.parent == null) {\r\n\r\n                    /* Flow of execution goes here when there is 1 node in tree */\r\n\r\n                    // Create internal node to serve as parent, use dictionary midpoint key\r\n                    Object[] parent_keys = new Object[this.m];\r\n                    parent_keys[0] = halfDict[0].key;\r\n                    InternalNode parent = new InternalNode(this.m, parent_keys);\r\n                    ln.parent = parent;\r\n                    parent.appendChildPointer(ln);\r\n\r\n                } else {\r\n\r\n                    /* Flow of execution goes here when parent exists */\r\n\r\n                    // Add new key to parent for proper indexing\r\n                    Object newParentKey = halfDict[0].key;\r\n                    ln.parent.keys[ln.parent.degree - 1] = newParentKey;\r\n                    Arrays.sort(ln.parent.keys, 0, ln.parent.degree);\r\n                }\r\n\r\n                // Create new LeafNode that holds the other half\r\n                LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);\r\n\r\n                // Update child pointers of parent node\r\n                int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;\r\n                ln.parent.insertChildPointer(newLeafNode, pointerIndex);\r\n\r\n                // Make leaf nodes siblings of one another\r\n                newLeafNode.rightSibling = ln.rightSibling;\r\n                if (newLeafNode.rightSibling != null) {\r\n                    newLeafNode.rightSibling.leftSibling = newLeafNode;\r\n                }\r\n                ln.rightSibling = newLeafNode;\r\n                newLeafNode.leftSibling = ln;\r\n\r\n                if (this.root == null) {\r\n\r\n                    // Set the root of B+ tree to be the parent\r\n                    this.root = ln.parent;\r\n\r\n                } else {\r\n\r\n\t\t\t\t\t/* If parent is overfull, repeat the process up the tree,\r\n\t\t\t   \t\t   until no deficiencies are found */\r\n                    InternalNode in = ln.parent;\r\n                    while (in != null) {\r\n                        if (in.isOverfull()) {\r\n                            splitInternalNode(in);\r\n                        } else {\r\n                            break;\r\n                        }\r\n                        in = in.parent;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a key, this method returns the value associated with the key\r\n     * within a dictionary pair that exists inside the B+ tree.\r\n     * @param key: the key to be searched within the B+ tree\r\n     * @return the floating point value associated with the key within the B+ tree\r\n     */\r\n    public ArrayList<Object> search(Object key) {\r\n//\t\t// If B+ tree is completely empty, simply return null\r\n//\t\tif (isEmpty()) { return null; }\r\n//\r\n//\t\t// Find leaf node that holds the dictionary key\r\n//\t\tLeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);\r\n//\r\n//\t\t// Perform binary search to find index of key within dictionary\r\n//\t\tDictionaryPair[] dps = ln.dictionary;\r\n//\t\tint index = binarySearch(dps, ln.numPairs, key);\r\n//\r\n//\t\t// If index negative, the key doesn't exist in B+ tree\r\n//\t\tif (index < 0) {\r\n//\t\t\treturn null;\r\n//\t\t} else {\r\n//\t\t\treturn dps[index].value;\r\n//\t\t}\r\n        return searchinclusive(key,key);\r\n    }\r\n\r\n    /**\r\n     * This method traverses the doubly linked list of the B+ tree and records\r\n     * all values whose associated keys are within the range specified by\r\n     * lowerBound and upperBound.\r\n     * @param lowerBound: (int) the lower bound of the range\r\n     * @param upperBound: (int) the upper bound of the range\r\n     * @return an ArrayList<Double> that holds all values of dictionary pairs\r\n     * whose keys are within the specified range\r\n     */\r\n    public ArrayList<Object> searchexclusive(Object lowerBound, Object upperBound) {\r\n\r\n        // Instantiate Double array to hold values\r\n        ArrayList<Object> values = new ArrayList<Object>();\r\n\r\n        // Iterate through the doubly linked list of leaves\r\n        LeafNode currNode = this.firstLeaf;\r\n        while (currNode != null) {\r\n\r\n            // Iterate through the dictionary of each node\r\n            DictionaryPair dps[] = currNode.dictionary;\r\n            for (DictionaryPair dp : dps) {\r\n\r\n\t\t\t\t/* Stop searching the dictionary once a null value is encountered\r\n\t\t\t\t   as this the indicates the end of non-null values */\r\n                if (dp == null) { break; }\r\n\r\n                // Include value if its key fits within the provided range\r\n                if (((Comparable) lowerBound).compareTo(dp.key) < 0 && ((Comparable) dp.key).compareTo(upperBound) < 0) {\r\n                    values.add(dp.value);\r\n                }\r\n\r\n            }\r\n\t\t\t/* Update the current node to be the right sibling,\r\n\t\t\t   leaf traversal is from left to right */\r\n            currNode = currNode.rightSibling;\r\n        }\r\n\r\n        return values;\r\n    }\r\n    public ArrayList<Object> searchinclusive(Object lowerBound, Object upperBound) {\r\n\r\n        // Instantiate Double array to hold values\r\n        ArrayList<Object> values = new ArrayList<Object>();\r\n\r\n        // Iterate through the doubly linked list of leaves\r\n        LeafNode currNode = this.firstLeaf;\r\n        while (currNode != null) {\r\n\r\n            // Iterate through the dictionary of each node\r\n            DictionaryPair dps[] = currNode.dictionary;\r\n            for (DictionaryPair dp : dps) {\r\n\r\n\t\t\t\t/* Stop searching the dictionary once a null value is encountered\r\n\t\t\t\t   as this the indicates the end of non-null values */\r\n                if (dp == null) { break; }\r\n\r\n                // Include value if its key fits within the provided range\r\n                if (((Comparable) lowerBound).compareTo(dp.key) <= 0 && ((Comparable) dp.key).compareTo(upperBound) <= 0) {\r\n                    values.add(dp.value);\r\n                }\r\n            }\r\n\t\t\t/* Update the current node to be the right sibling,\r\n\t\t\t   leaf traversal is from left to right */\r\n            currNode = currNode.rightSibling;\r\n\r\n        }\r\n        return values;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * This class represents a general node within the B+ tree and serves as a\r\n     * superclass of InternalNode and LeafNode.\r\n     */\r\n    public class Node {\r\n        InternalNode parent;\r\n    }\r\n\r\n    /**\r\n     * This class represents the internal nodes within the B+ tree that traffic\r\n     * all search/insert/delete operations. An internal node only holds keys; it\r\n     * does not hold dictionary pairs.\r\n     */\r\n    private class InternalNode extends Node {\r\n        int maxDegree;\r\n        int minDegree;\r\n        int degree;\r\n        InternalNode leftSibling;\r\n        InternalNode rightSibling;\r\n        Object[] keys;\r\n        Object[] values;\r\n        Node[] childPointers;\r\n\r\n        /**\r\n         * This method appends 'pointer' to the end of the childPointers\r\n         * instance variable of the InternalNode object. The pointer can point to\r\n         * an InternalNode object or a LeafNode object since the formal\r\n         * parameter specifies a Node object.\r\n         * @param pointer: Node pointer that is to be appended to the\r\n         *                    childPointers list\r\n         */\r\n        private void appendChildPointer(Node pointer) {\r\n            this.childPointers[degree] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * Given a Node pointer, this method will return the index of where the\r\n         * pointer lies within the childPointers instance variable. If the pointer\r\n         * can't be found, the method returns -1.\r\n         * @param pointer: a Node pointer that may lie within the childPointers\r\n         *                     instance variable\r\n         * @return the index of 'pointer' within childPointers, or -1 if\r\n         * 'pointer' can't be found\r\n         */\r\n        private int findIndexOfPointer(Node pointer) {\r\n            for (int i = 0; i < childPointers.length; i++) {\r\n                if (childPointers[i] == pointer) { return i; }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        /**\r\n         * Given a pointer to a Node object and an integer index, this method\r\n         * inserts the pointer at the specified index within the childPointers\r\n         * instance variable. As a result of the insert, some pointers may be\r\n         * shifted to the right of the index.\r\n         * @param pointer: the Node pointer to be inserted\r\n         * @param index: the index at which the insert is to take place\r\n         */\r\n        private void insertChildPointer(Node pointer, int index) {\r\n            for (int i = degree - 1; i >= index ;i--) {\r\n                childPointers[i + 1] = childPointers[i];\r\n            }\r\n            this.childPointers[index] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is deficient or not.\r\n         * An InternalNode is deficient when its current degree of children falls\r\n         * below the allowed minimum.\r\n         * @return a boolean indicating whether the InternalNode is deficient\r\n         * or not\r\n         */\r\n        private boolean isDeficient() {\r\n            return this.degree < this.minDegree;\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is capable of\r\n         * lending one of its dictionary pairs to a deficient node. An InternalNode\r\n         * can give away a dictionary pair if its current degree is above the\r\n         * specified minimum.\r\n         * @return a boolean indicating whether or not the InternalNode has\r\n         * enough dictionary pairs in order to give one away.\r\n         */\r\n        private boolean isLendable() { return this.degree > this.minDegree; }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is capable of being\r\n         * merged with. An InternalNode can be merged with if it has the minimum\r\n         * degree of children.\r\n         * @return a boolean indicating whether or not the InternalNode can be\r\n         * merged with\r\n         */\r\n        private boolean isMergeable() { return this.degree == this.minDegree; }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is considered overfull,\r\n         * i.e. the InternalNode object's current degree is one more than the\r\n         * specified maximum.\r\n         * @return a boolean indicating if the InternalNode is overfull\r\n         */\r\n        private boolean isOverfull() {\r\n            return this.degree == maxDegree + 1;\r\n        }\r\n\r\n        /**\r\n         * Given a pointer to a Node object, this method inserts the pointer to\r\n         * the beginning of the childPointers instance variable.\r\n         * @param pointer: the Node object to be prepended within childPointers\r\n         */\r\n        private void prependChildPointer(Node pointer) {\r\n            for (int i = degree - 1; i >= 0 ;i--) {\r\n                childPointers[i + 1] = childPointers[i];\r\n            }\r\n            this.childPointers[0] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * This method sets keys[index] to null. This method is used within the\r\n         * parent of a merging, deficient LeafNode.\r\n         * @param index: the location within keys to be set to null\r\n         */\r\n        private void removeKey(int index) { this.keys[index] = null; this.values[index] =null;}\r\n\r\n        /**\r\n         * This method sets childPointers[index] to null and additionally\r\n         * decrements the current degree of the InternalNode.\r\n         * @param index: the location within childPointers to be set to null\r\n         */\r\n        private void removePointer(int index) {\r\n            this.childPointers[index] = null;\r\n            this.degree--;\r\n        }\r\n\r\n        /**\r\n         * This method removes 'pointer' from the childPointers instance\r\n         * variable and decrements the current degree of the InternalNode. The\r\n         * index where the pointer node was assigned is set to null.\r\n         * @param pointer: the Node pointer to be removed from childPointers\r\n         */\r\n        private void removePointer(Node pointer) {\r\n            for (int i = 0; i < childPointers.length; i++) {\r\n                if (childPointers[i] == pointer) { this.childPointers[i] = null; }\r\n            }\r\n            this.degree--;\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: the max degree of the InternalNode\r\n         * @param keys: the list of keys that InternalNode is initialized with\r\n         */\r\n        private InternalNode(int m, Object[] keys , Object[] values) {\r\n            this.maxDegree = m;\r\n            this.minDegree = (int)Math.ceil(m/2.0);\r\n            this.degree = 0;\r\n            this.keys = keys;\r\n            this.values = values ;\r\n            this.childPointers = new Node[this.maxDegree+1];\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: the max degree of the InternalNode\r\n         * @param keys: the list of keys that InternalNode is initialized with\r\n         * @param pointers: the list of pointers that InternalNode is initialized with\r\n         */\r\n        private InternalNode(int m, Object[] keys, Object[] values, Node[] pointers) {\r\n            this.maxDegree = m;\r\n            this.minDegree = (int)Math.ceil(m/2.0);\r\n            this.degree = linearNullSearch(pointers);\r\n            this.keys = keys;\r\n            this.values = values ;\r\n            this.childPointers = pointers;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class represents the leaf nodes within the B+ tree that hold\r\n     * dictionary pairs. The leaf node has no children. The leaf node has a\r\n     * minimum and maximum number of dictionary pairs it can hold, as specified\r\n     * by m, the max degree of the B+ tree. The leaf nodes form a doubly linked\r\n     * list that, i.e. each leaf node has a left and right sibling*/\r\n    public class LeafNode extends Node {\r\n        int maxNumPairs;\r\n        int minNumPairs;\r\n        int numPairs;\r\n        LeafNode leftSibling;\r\n        LeafNode rightSibling;\r\n        DictionaryPair[] dictionary;\r\n\r\n\r\n        // 2,3,5,1,7 -> // 1,2,3,5,7\r\n        // 1,2,3,4,5 -> // 1,2,3,4,5\r\n\r\n        /**\r\n         * Given an index, this method sets the dictionary pair at that index\r\n         * within the dictionary to null.\r\n         * @param index: the location within the dictionary to be set to null\r\n         */\r\n        public void delete(int index) {\r\n\r\n            // Delete dictionary pair from leaf\r\n            this.dictionary[index] = null;\r\n\r\n            // Decrement numPairs\r\n            numPairs--;\r\n        }\r\n\r\n        /**\r\n         * This method attempts to insert a dictionary pair within the dictionary\r\n         * of the LeafNode object. If it succeeds, numPairs increments, the\r\n         * dictionary is sorted, and the boolean true is returned. If the method\r\n         * fails, the boolean false is returned.\r\n         * @param dp: the dictionary pair to be inserted\r\n         * @return a boolean indicating whether or not the insert was successful\r\n         */\r\n        public boolean insert(DictionaryPair dp) {\r\n            if (this.isFull()) {\r\n\r\n                /* Flow of execution goes here when numPairs == maxNumPairs */\r\n\r\n                return false;\r\n            } else {\r\n\r\n                // Insert dictionary pair, increment numPairs, sort dictionary\r\n                this.dictionary[numPairs] = dp;\r\n                numPairs++;\r\n                Arrays.sort(this.dictionary, 0, numPairs);\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode is deficient, i.e.\r\n         * the numPairs within the LeafNode object is below minNumPairs.\r\n         * @return a boolean indicating whether or not the LeafNode is deficient\r\n         */\r\n        public boolean isDeficient() { return numPairs < minNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode is full, i.e. the\r\n         * numPairs within the LeafNode is equal to the maximum number of pairs.\r\n         * @return a boolean indicating whether or not the LeafNode is full\r\n         */\r\n        public boolean isFull() { return numPairs == maxNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode object is capable of\r\n         * lending a dictionary pair to a deficient leaf node. The LeafNode\r\n         * object can lend a dictionary pair if its numPairs is greater than\r\n         * the minimum number of pairs it can hold.\r\n         * @return a boolean indicating whether or not the LeafNode object can\r\n         * give a dictionary pair to a deficient leaf node\r\n         */\r\n        public boolean isLendable() { return numPairs > minNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode object is capable of\r\n         * being merged with, which occurs when the number of pairs within the\r\n         * LeafNode object is equal to the minimum number of pairs it can hold.\r\n         * @return a boolean indicating whether or not the LeafNode object can\r\n         * be merged with\r\n         */\r\n        public boolean isMergeable() {\r\n            return numPairs == minNumPairs;\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: order of B+ tree that is used to calculate maxNumPairs and\r\n         *           minNumPairs\r\n         * @param dp: first dictionary pair insert into new node\r\n         */\r\n        public LeafNode(int m, DictionaryPair dp) {\r\n            this.maxNumPairs = m - 1;\r\n            this.minNumPairs = (int)(Math.ceil(m/2) - 1);\r\n            this.dictionary = new DictionaryPair[m];\r\n            this.numPairs = 0;\r\n            this.insert(dp);\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param dps: list of DictionaryPair objects to be immediately inserted\r\n         *             into new LeafNode object\r\n         * @param m: order of B+ tree that is used to calculate maxNumPairs and\r\n         * \t\t     minNumPairs\r\n         * @param parent: parent of newly created child LeafNode\r\n         */\r\n        public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {\r\n            this.maxNumPairs = m - 1;\r\n            this.minNumPairs = (int)(Math.ceil(m/2) - 1);\r\n            this.dictionary = dps;\r\n            this.numPairs = linearNullSearch(dps);\r\n            this.parent = parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class represents a dictionary pair that is to be contained within the\r\n     * leaf nodes of the B+ tree. The class implements the Comparable interface\r\n     * so that the DictionaryPair objects can be sorted later on.\r\n     */\r\n    public class DictionaryPair implements Comparable<DictionaryPair> {\r\n//        Object key;\r\n//        Object value;\r\n        Pair<Object , Object>kvPair  ;\r\n        /**\r\n         * Constructor\r\n         * @param key: the key of the key-value pair\r\n         * @param value: the value of the key-value pair\r\n         */\r\n        public DictionaryPair(Pair<Object ,Object>kvPair) {\r\n            this.kvPair = kvPair ;\r\n        }\r\n\r\n        /**\r\n         * This is a method that allows comparisons to take place between\r\n         * DictionaryPair objects in order to sort them later on\r\n         * @param o\r\n         * @return\r\n         */\r\n        @Override\r\n        public int compareTo(DictionaryPair o) {\r\n            if (kvPair..equals(o.key)) {\r\n                return 0;\r\n            } else if (key instanceof Integer && o.key instanceof Integer) {\r\n                return Integer.compare((Integer) key, (Integer) o.key);\r\n            } else if (key instanceof String && o.key instanceof String) {\r\n                return ((String) key).compareTo((String) o.key);\r\n            } else if (key instanceof Double && o.key instanceof Double) {\r\n                return Double.compare((Double) key, (Double) o.key);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Keys must be of the same type and comparable\");\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder treeString = new StringBuilder();\r\n        appendNodeToString(root, treeString, 0);\r\n        return treeString.toString();\r\n    }\r\n\r\n    private void appendNodeToString(Node node, StringBuilder treeString, int level) {\r\n        if (node instanceof LeafNode) {\r\n            appendLeafNodeToString((LeafNode) node, treeString, level);\r\n        } else if (node instanceof InternalNode) {\r\n            appendInternalNodeToString((InternalNode) node, treeString, level);\r\n        }\r\n    }\r\n\r\n    private void appendLeafNodeToString(LeafNode leafNode, StringBuilder treeString, int level) {\r\n        treeString.append(\"Leaf Node (Level \").append(level).append(\"): \");\r\n        for (int i = 0; i < leafNode.numPairs; i++) {\r\n            DictionaryPair pair = leafNode.dictionary[i];\r\n            treeString.append(\"(\").append(pair.key).append(\", \").append(pair.value).append(\") \");\r\n        }\r\n        treeString.append(\"\\n\");\r\n    }\r\n\r\n    private void appendInternalNodeToString(InternalNode internalNode, StringBuilder treeString, int level) {\r\n        treeString.append(\"Internal Node (Level \").append(level).append(\"): \");\r\n        for (int i = 0; i < internalNode.degree - 1; i++) {\r\n            treeString.append(internalNode.keys[i]).append(\" \");\r\n        }\r\n        treeString.append(\"\\n\");\r\n\r\n        for (int i = 0; i < internalNode.degree; i++) {\r\n            appendNodeToString(internalNode.childPointers[i], treeString, level + 1);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // Ensure correct number of arguments\r\n//\t\tif (args.length != 1) {\r\n//\t\t\tSystem.err.println(\"usage: java bplustree <file_name>\");\r\n//\t\t\tSystem.exit(-1);\r\n//\t\t}\r\n\r\n        // Read from file\r\n//\t\tString fileName = args[0];\r\n        try {\r\n\r\n\r\n            // Prepare to read input file\r\n//\t\t\tFile file = new File(System.getProperty(\"user.dir\") + \"/\" + fileName);\r\n//\t\t\tScanner sc = new Scanner(file);\r\n\r\n            // Create output file in which search results will be stored\r\n//\t\t\tFileWriter logger = new FileWriter(\"output_file.txt\", false);\r\n//\t\t\tboolean firstLine = true;\r\n\r\n            // Create initial B+ tree\r\n            BPlusIndex bpt = new BPlusIndex(3,\"\",\"\",\"\");\r\n            bpt.insert(\"Ahmed\",\"Ahmed\");\r\n            bpt.insert(\"JJ\",\"PlaceofJJ\");\r\n            System.out.println(bpt.search(\"Ahmed\"));\r\n//\t\t\tbpt.insert(\"JJ\",\"PlaceofJJ2\");\r\n//            bpt.delete(\"JJ\");\r\n            System.out.println(bpt.search(\"JJ\"));\r\n            bpt.insert(\"R\",\"placeofR\");\r\n            System.out.println(bpt.search(\"R\"));\r\n            bpt.insert(\"Banana\",\"PlaceofBanana\");\r\n//            System.out.println(bpt.search(\"Ahmed\",\"R\"));\r\n\r\n//\t\t\tbpt.insert(21,\"PlaceofInt\");\r\n//\t\t\tSystem.out.println(bpt.search(21));\r\n//\r\n//\t\t\tbpt.insert(2.5,\"PlaceofDouble\");\r\n//\t\t\tSystem.out.println(bpt.search(2.5));\r\n\r\n\r\n\r\n            // Perform an operation for each line in the input file\r\n//\t\t\twhile (sc.hasNextLine()) {\r\n//\t\t\t\tString line = sc.nextLine().replace(\" \", \"\");\r\n//\t\t\t\tString[] tokens = line.split(\"[(,)]\");\r\n//\r\n//\t\t\t\tswitch (tokens[0]) {\r\n//\r\n//\t\t\t\t\t// Initializes an m-order B+ tree\r\n//\t\t\t\t\tcase \"Initialize\":\r\n//\t\t\t\t\t\tbpt = new bplustree(Integer.parseInt(tokens[1]));\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Insert a dictionary pair into the B+ tree\r\n//\t\t\t\t\tcase \"Insert\":\r\n//\t\t\t\t\t\tbpt.insert(tokens[1], tokens[2]);\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Delete a dictionary pair from the B+ tree\r\n//\t\t\t\t\tcase \"Delete\":\r\n//\t\t\t\t\t\tbpt.delete(tokens[1]);\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Perform a search or search operation on the B+ tree\r\n//\t\t\t\t\tcase \"Search\":\r\n//\t\t\t\t\t\tString result = \"\";\r\n//\r\n//\t\t\t\t\t\t// Perform search (across a range) operation\r\n//\t\t\t\t\t\tif (tokens.length == 3) {\r\n//\t\t\t\t\t\t\tArrayList<String> values = bpt.search(\r\n//\t\t\t\t\t\t\t\t\t\t\ttokens[1],\r\n//\t\t\t\t\t\t\t\t\t\t\ttokens[2]);\r\n//\r\n//\t\t\t\t\t\t\t// Record search result as a String\r\n//\t\t\t\t\t\t\tif (values.size() != 0) {\r\n//\t\t\t\t\t\t\t\tfor (String v : values) { result += v + \", \"; }\r\n//\t\t\t\t\t\t\t\tresult = result.substring(0, result.length() - 2);\r\n//\t\t\t\t\t\t\t} else {\r\n//\t\t\t\t\t\t\t\tresult = \"Null\";\r\n//\t\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// Perform search operation\r\n//\t\t\t\t\t\telse {\r\n//\r\n//\t\t\t\t\t\t\t/* Perform search for key, if resulting value is\r\n//\t\t\t\t\t\t\t   null, then the key could not be found */\r\n//\t\t\t\t\t\t\tString value = bpt.search(tokens[1]);\r\n//\t\t\t\t\t\t\tresult = (value == null) ? \"Null\" :\r\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue;\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// Output search result in .txt file\r\n//\t\t\t\t\t\tif (firstLine) {\r\n//\t\t\t\t\t\t\tlogger.write(result);\r\n//\t\t\t\t\t\t\tfirstLine = false;\r\n//\t\t\t\t\t\t} else {\r\n//\t\t\t\t\t\t\tlogger.write(\"\\n\" + result);\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\tlogger.flush();\r\n//\r\n//\t\t\t\t\t\tbreak;\r\n//\t\t\t\t\tdefault:\r\n//\t\t\t\t\t\tthrow new IllegalArgumentException(\"\\\"\" + tokens[0] +\r\n//\t\t\t\t\t\t\t\t\"\\\"\" + \" is an unacceptable input.\");\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\r\n            // Close output file\r\n//\t\t\tlogger.close();\r\n\r\n//\t\t} catch (FileNotFoundException e) {\r\n//\t\t\tSystem.err.println(e);\r\n        } catch (IllegalArgumentException e) {\r\n            System.err.println(e);\r\n//\t\t} catch (IOException e) {\r\n//\t\t\tSystem.err.println(e);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Data/Index/BPlusIndex.java b/Data/Index/BPlusIndex.java
--- a/Data/Index/BPlusIndex.java	(revision 6822d680d4fb896fb8542aa5a48abfb30570e1d5)
+++ b/Data/Index/BPlusIndex.java	(date 1710465805790)
@@ -71,10 +71,9 @@
      * @param key: the unique key that lies within the dictionary of a LeafNode object
      * @return the LeafNode object that contains the key within its dictionary
      */
-    private LeafNode findLeafNode(Object key , Object value) {
+    private LeafNode findLeafNode(Object key) {
         // Initialize keys and index variable
         Object[] keys = this.root.keys;
-        Object[] values = this.root.values ;
         int i;
 
         // Find next node on path to appropriate leaf node
@@ -365,7 +364,6 @@
         Object newParentKey = in.keys[midpoint];
         Object newParentValue = in.values[midpoint];
         Object[] halfKeys = splitKeys(in.keys, midpoint);
-        Object[] halfValues = splitValues(in.values , midpoint);
         Node[] halfPointers = splitChildPointers(in, midpoint);
 
         // Change degree of original InternalNode in
@@ -434,20 +432,7 @@
 
         return halfKeys;
     }
-    private Object[] splitValues(Object[] values, int split) {
-        Object[] halfValues = new Object[this.m];
-
-        // Remove split-indexed value from keys
-        values[split] = null;
 
-        // Copy half of the values into halfKeys while updating original keys
-        for (int i = split + 1; i < values.length; i++) {
-            halfValues[i - split - 1] = values[i];
-            values[i] = null;
-        }
-
-        return halfValues;
-    }
 
 
     /*~~~~~~~~~~~~~~~~ API: DELETE, INSERT, SEARCH ~~~~~~~~~~~~~~~~*/
@@ -812,7 +797,6 @@
         InternalNode leftSibling;
         InternalNode rightSibling;
         Object[] keys;
-        Object[] values;
         Node[] childPointers;
 
         /**
@@ -953,10 +937,8 @@
             this.minDegree = (int)Math.ceil(m/2.0);
             this.degree = 0;
             this.keys = keys;
-            this.values = values ;
             this.childPointers = new Node[this.maxDegree+1];
         }
-
         /**
          * Constructor
          * @param m: the max degree of the InternalNode
@@ -968,7 +950,6 @@
             this.minDegree = (int)Math.ceil(m/2.0);
             this.degree = linearNullSearch(pointers);
             this.keys = keys;
-            this.values = values ;
             this.childPointers = pointers;
         }
     }
