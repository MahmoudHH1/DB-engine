Index: Data/Index/BPlusIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Data.Index;\r\nimport Data.Handler.FileCreator;\r\nimport Data.Handler.Pair;\r\n//import org.antlr.v4.runtime.misc.Pair;\r\n//import com.sun.corba.se.impl.orbutil.ObjectWriter;\r\n\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\nimport java.util.Vector;\r\n\r\npublic class BPlusIndex implements Serializable {\r\n    int m;\r\n    InternalNode root;\r\n    LeafNode firstLeaf;\r\n    private String tableName;\r\n    private String colName;\r\n    private String idxName ;\r\n    private String path ;\r\n    /**\r\n     * Constructor\r\n     * @param m: the order (fanout) of the B+ tree\r\n     */\r\n    public BPlusIndex(int m,String tableName,String colName , String idxName) {\r\n        this.m = m;\r\n        this.root = null;\r\n        this.tableName=tableName;\r\n        this.colName=colName;\r\n        this.idxName = idxName ;\r\n        this.path = \"Data_Entry\" + File.separator +\r\n                    \"Tables\"+ File.separator +\r\n                    tableName + File.separator+\r\n                    \"indices\"+File.separator+\r\n                    idxName;\r\n    }\r\n    public String getIndexPath(){\r\n        return this.path ;\r\n    }\r\n    public void save() throws IOException {\r\n        FileCreator.storeAsObject(this, path);\r\n    }\r\n    public String getTableName(){return tableName;}\r\n    public String getColName(){return colName;}\r\n    public String getIdxName(){return idxName;};\r\n    /*~~~~~~~~~~~~~~~~ HELPER FUNCTIONS ~~~~~~~~~~~~~~~~*/\r\n\r\n    /**\r\n     * This method performs a standard binary search on a sorted\r\n     * DictionaryPair[] and returns the index of the dictionary pair\r\n     * with target key t if found. Otherwise, this method returns a negative\r\n     * value.\r\n     * @param dps: list of dictionary pairs sorted by key within leaf node\r\n     * @param t: target key value of dictionary pair being searched for\r\n     * @return index of the target value if found, else a negative value\r\n     */\r\n    private int binarySearch(DictionaryPair[] dps, int numPairs, Object t) {\r\n        Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {\r\n            @Override\r\n            public int compare(DictionaryPair o1, DictionaryPair o2) {\r\n                return o1.compareTo(o2);\r\n            }\r\n        };\r\n        return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, \"\"), c);\r\n    }\r\n\r\n    /**\r\n     * This method starts at the root of the B+ tree and traverses down the\r\n     * tree via key comparisons to the corresponding leaf node that holds 'key'\r\n     * within its dictionary.\r\n     * @param key: the unique key that lies within the dictionary of a LeafNode object\r\n     * @return the LeafNode object that contains the key within its dictionary\r\n     */\r\n    private LeafNode findLeafNode(Object key) {\r\n        // Initialize keys and index variable\r\n        Object[] keys = this.root.keys;\r\n        int i;\r\n\r\n        // Find next node on path to appropriate leaf node\r\n        for (i = 0; i < this.root.degree - 1; i++) {\r\n            if (compareKeys(key, keys[i]) < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    /* Return node if it is a LeafNode object,\r\n       otherwise repeat the search function a level down */\r\n        Node child = this.root.childPointers[i];\r\n        if (child instanceof LeafNode) {\r\n            return (LeafNode) child;\r\n        } else {\r\n            return findLeafNode((InternalNode) child, key);\r\n        }\r\n    }\r\n    private LeafNode findLeafNode(InternalNode node, Object key) {\r\n        // Initialize keys and index variable\r\n        Object[] keys = node.keys;\r\n        int i;\r\n\r\n        // Find next node on path to appropriate leaf node\r\n        for (i = 0; i < node.degree - 1; i++) {\r\n            if (compareKeys(key, keys[i]) < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    /* Return node if it is a LeafNode object,\r\n       otherwise repeat the search function a level down */\r\n        Node childNode = node.childPointers[i];\r\n        if (childNode instanceof LeafNode) {\r\n            return (LeafNode) childNode;\r\n        } else {\r\n            return findLeafNode((InternalNode) childNode, key);\r\n        }\r\n    }\r\n\r\n    private int compareKeys(Object key1, Object key2) {\r\n        if (key1 instanceof Comparable && key2 instanceof Comparable) {\r\n            return ((Comparable) key1).compareTo(key2);\r\n        }\r\n        throw new IllegalArgumentException(\"Keys are not comparable.\");\r\n    }\r\n\r\n    /**\r\n     * Given a list of pointers to Node objects, this method returns the index of\r\n     * the pointer that points to the specified 'node' LeafNode object.\r\n     * @param pointers: a list of pointers to Node objects\r\n     * @param node: a specific pointer to a LeafNode\r\n     * @return (int) index of pointer in list of pointers\r\n     */\r\n    private int findIndexOfPointer(Node[] pointers, LeafNode node) {\r\n        int i;\r\n        for (i = 0; i < pointers.length; i++) {\r\n            if (pointers[i] == node) { break; }\r\n        }\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * This is a simple method that returns the midpoint (or lower bound\r\n     * depending on the context of the method invocation) of the max degree m of\r\n     * the B+ tree.\r\n     * @return (int) midpoint/lower bound\r\n     */\r\n    private int getMidpoint() {\r\n        return (int)Math.ceil((this.m + 1) / 2.0) - 1;\r\n    }\r\n\r\n    /**\r\n     * Given a deficient InternalNode in, this method remedies the deficiency\r\n     * through borrowing and merging.\r\n     * @param in: a deficient InternalNode\r\n     */\r\n    private void handleDeficiency(InternalNode in) {\r\n\r\n        InternalNode sibling;\r\n        InternalNode parent = in.parent;\r\n\r\n        // Remedy deficient root node\r\n        if (this.root == in) {\r\n            for (int i = 0; i < in.childPointers.length; i++) {\r\n                if (in.childPointers[i] != null) {\r\n                    if (in.childPointers[i] instanceof InternalNode) {\r\n                        this.root = (InternalNode)in.childPointers[i];\r\n                        this.root.parent = null;\r\n                    } else if (in.childPointers[i] instanceof LeafNode) {\r\n                        this.root = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Borrow:\r\n        else if (in.leftSibling != null && in.leftSibling.isLendable()) {\r\n            sibling = in.leftSibling;\r\n        } else if (in.rightSibling != null && in.rightSibling.isLendable()) {\r\n            sibling = in.rightSibling;\r\n\r\n            // Copy 1 key and pointer from sibling (atm just 1 key)\r\n            Object borrowedKey = sibling.keys[0];\r\n            Node pointer = sibling.childPointers[0];\r\n\r\n            // Copy root key and pointer into parent\r\n            in.keys[in.degree - 1] = parent.keys[0];\r\n            in.childPointers[in.degree] = pointer;\r\n\r\n            // Copy borrowedKey into root\r\n            parent.keys[0] = borrowedKey;\r\n\r\n            // Delete key and pointer from sibling\r\n            sibling.removePointer(0);\r\n            Arrays.sort(sibling.keys);\r\n            sibling.removePointer(0);\r\n            shiftDown(in.childPointers, 1);\r\n        }\r\n\r\n        // Merge:\r\n        else if (in.leftSibling != null && in.leftSibling.isMergeable()) {\r\n\r\n        } else if (in.rightSibling != null && in.rightSibling.isMergeable()) {\r\n            sibling = in.rightSibling;\r\n\r\n            // Copy rightmost key in parent to beginning of sibling's keys &\r\n            // delete key from parent\r\n            sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];\r\n            Arrays.sort(sibling.keys, 0, sibling.degree);\r\n            parent.keys[parent.degree - 2] = null;\r\n\r\n            // Copy in's child pointer over to sibling's list of child pointers\r\n            for (int i = 0; i < in.childPointers.length; i++) {\r\n                if (in.childPointers[i] != null) {\r\n                    sibling.prependChildPointer(in.childPointers[i]);\r\n                    in.childPointers[i].parent = sibling;\r\n                    in.removePointer(i);\r\n                }\r\n            }\r\n\r\n            // Delete child pointer from grandparent to deficient node\r\n            parent.removePointer(in);\r\n\r\n            // Remove left sibling\r\n            sibling.leftSibling = in.leftSibling;\r\n        }\r\n\r\n        // Handle deficiency a level up if it exists\r\n        if (parent != null && parent.isDeficient()) {\r\n            handleDeficiency(parent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is a simple method that determines if the B+ tree is empty or not.\r\n     * @return a boolean indicating if the B+ tree is empty or not\r\n     */\r\n    private boolean isEmpty() {\r\n        return firstLeaf == null;\r\n    }\r\n\r\n    /**\r\n     * This method performs a standard linear search on a sorted\r\n     * DictionaryPair[] and returns the index of the first null entry found.\r\n     * Otherwise, this method returns a -1. This method is primarily used in\r\n     * place of binarySearch() when the target t = null.\r\n     * @param dps: list of dictionary pairs sorted by key within leaf node\r\n     * @return index of the target value if found, else -1\r\n     */\r\n    private int linearNullSearch(DictionaryPair[] dps) {\r\n        for (int i = 0; i <  dps.length; i++) {\r\n            if (dps[i] == null) { return i; }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This method performs a standard linear search on a list of Node[] pointers\r\n     * and returns the index of the first null entry found. Otherwise, this\r\n     * method returns a -1. This method is primarily used in place of\r\n     * binarySearch() when the target t = null.\r\n     * @param pointers: list of Node[] pointers\r\n     * @return index of the target value if found, else -1\r\n     */\r\n    private int linearNullSearch(Node[] pointers) {\r\n        for (int i = 0; i <  pointers.length; i++) {\r\n            if (pointers[i] == null) { return i; }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This method is used to shift down a set of pointers that are prepended\r\n     * by null values.\r\n     * @param pointers: the list of pointers that are to be shifted\r\n     * @param amount: the amount by which the pointers are to be shifted\r\n     */\r\n    private void shiftDown(Node[] pointers, int amount) {\r\n        Node[] newPointers = new Node[this.m + 1];\r\n        for (int i = amount; i < pointers.length; i++) {\r\n            newPointers[i - amount] = pointers[i];\r\n        }\r\n        pointers = newPointers;\r\n    }\r\n\r\n    /**\r\n     * This is a specialized sorting method used upon lists of DictionaryPairs\r\n     * that may contain interspersed null values.\r\n     * @param dictionary: a list of DictionaryPair objects\r\n     */\r\n    private void sortDictionary(DictionaryPair[] dictionary) {\r\n        Arrays.sort(dictionary, new Comparator<DictionaryPair>() {\r\n            @Override\r\n            public int compare(DictionaryPair o1, DictionaryPair o2) {\r\n                if (o1 == null && o2 == null) { return 0; }\r\n                if (o1 == null) { return 1; }\r\n                if (o2 == null) { return -1; }\r\n                return o1.compareTo(o2);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This method modifies the InternalNode 'in' by removing all pointers within\r\n     * the childPointers after the specified split. The method returns the removed\r\n     * pointers in a list of their own to be used when constructing a new\r\n     * InternalNode sibling.\r\n     * @param in: an InternalNode whose childPointers will be split\r\n     * @param split: the index at which the split in the childPointers begins\r\n     * @return a Node[] of the removed pointers\r\n     */\r\n    private Node[] splitChildPointers(InternalNode in, int split) {\r\n\r\n        Node[] pointers = in.childPointers;\r\n        Node[] halfPointers = new Node[this.m + 1];\r\n\r\n        // Copy half of the values into halfPointers while updating original keys\r\n        for (int i = split + 1; i < pointers.length; i++) {\r\n            halfPointers[i - split - 1] = pointers[i];\r\n            in.removePointer(i);\r\n        }\r\n\r\n        return halfPointers;\r\n    }\r\n\r\n    /**\r\n     * This method splits a single dictionary into two dictionaries where all\r\n     * dictionaries are of equal length, but each of the resulting dictionaries\r\n     * holds half of the original dictionary's non-null values. This method is\r\n     * primarily used when splitting a node within the B+ tree. The dictionary of\r\n     * the specified LeafNode is modified in place. The method returns the\r\n     * remainder of the DictionaryPairs that are no longer within ln's dictionary.\r\n     * @param ln: list of DictionaryPairs to be split\r\n     * @param split: the index at which the split occurs\r\n     * @return DictionaryPair[] of the two split dictionaries\r\n     */\r\n    private DictionaryPair[] splitDictionary(LeafNode ln, int split) {\r\n\r\n        DictionaryPair[] dictionary = ln.dictionary;\r\n\r\n\t\t/* Initialize two dictionaries that each hold half of the original\r\n\t\t   dictionary values */\r\n        DictionaryPair[] halfDict = new DictionaryPair[this.m];\r\n\r\n        // Copy half of the values into halfDict\r\n        for (int i = split; i < dictionary.length; i++) {\r\n            halfDict[i - split] = dictionary[i];\r\n            ln.delete(i);\r\n        }\r\n\r\n        return halfDict;\r\n    }\r\n\r\n    /**\r\n     * When an insertion into the B+ tree causes an overfull node, this method\r\n     * is called to remedy the issue, i.e. to split the overfull node. This method\r\n     * calls the sub-methods of splitKeys() and splitChildPointers() in order to\r\n     * split the overfull node.\r\n     * @param in: an overfull InternalNode that is to be split\r\n     */\r\n    private void splitInternalNode(InternalNode in) {\r\n        // Acquire parent\r\n        InternalNode parent = in.parent;\r\n\r\n        // Split keys and pointers in half\r\n        int midpoint = getMidpoint();\r\n        Object newParentKey = in.keys[midpoint];\r\n        Object[] halfKeys = splitKeys(in.keys, midpoint);\r\n        Node[] halfPointers = splitChildPointers(in, midpoint);\r\n\r\n        // Change degree of original InternalNode in\r\n        in.degree = linearNullSearch(in.childPointers);\r\n\r\n        // Create new sibling internal node and add half of keys and pointers\r\n        InternalNode sibling = new InternalNode(this.m, halfKeys, halfPointers);\r\n        for (Node pointer : halfPointers) {\r\n            if (pointer != null) {\r\n                pointer.parent = sibling;\r\n            }\r\n        }\r\n\r\n        // Make internal nodes siblings of one another\r\n        sibling.rightSibling = in.rightSibling;\r\n        if (sibling.rightSibling != null) {\r\n            sibling.rightSibling.leftSibling = sibling;\r\n        }\r\n        in.rightSibling = sibling;\r\n        sibling.leftSibling = in;\r\n\r\n        if (parent == null) {\r\n            // Create new root node and add midpoint key and pointers\r\n            Object[] keys = new Object[this.m];\r\n            Object[] values = new Object[this.m] ;\r\n            keys[0] = newParentKey;\r\n            InternalNode newRoot = new InternalNode(this.m, keys ,values);\r\n            newRoot.appendChildPointer(in);\r\n            newRoot.appendChildPointer(sibling);\r\n            this.root = newRoot;\r\n\r\n            // Add pointers from children to parent\r\n            in.parent = newRoot;\r\n            sibling.parent = newRoot;\r\n        } else {\r\n            // Add key to parent\r\n            parent.keys[parent.degree - 1] = newParentKey;\r\n            Arrays.sort(parent.keys, 0, parent.degree);\r\n\r\n            // Set up pointer to new sibling\r\n            int pointerIndex = parent.findIndexOfPointer(in) + 1;\r\n            parent.insertChildPointer(sibling, pointerIndex);\r\n            sibling.parent = parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method modifies a list of Integer-typed objects that represent keys\r\n     * by removing half of the keys and returning them in a separate Integer[].\r\n     * This method is used when splitting an InternalNode object.\r\n     * @param keys: a list of Integer objects\r\n     * @param split: the index where the split is to occur\r\n     * @return Integer[] of removed keys\r\n     */\r\n    private Object[] splitKeys(Object[] keys, int split) {\r\n        Object[] halfKeys = new Object[this.m];\r\n\r\n        // Remove split-indexed value from keys\r\n        keys[split] = null;\r\n\r\n        // Copy half of the values into halfKeys while updating original keys\r\n        for (int i = split + 1; i < keys.length; i++) {\r\n            halfKeys[i - split - 1] = keys[i];\r\n            keys[i] = null;\r\n        }\r\n\r\n        return halfKeys;\r\n    }\r\n    /*~~~~~~~~~~~~~~~~ API: DELETE, INSERT, SEARCH ~~~~~~~~~~~~~~~~*/\r\n\r\n    /**\r\n     * Given a key, this method will remove the dictionary pair with the\r\n     * corresponding key from the B+ tree.\r\n     * @param key: an integer key that corresponds with an existing dictionary\r\n     *             pair\r\n     */\r\n    public void delete(Object key , Object value) {\r\n        if (isEmpty()) {\r\n\r\n            /* Flow of execution goes here when B+ tree has no dictionary pairs */\r\n\r\n            System.err.println(\"Invalid Delete: The B+ tree is currently empty.\");\r\n\r\n        } else {\r\n\r\n            // Get leaf node and attempt to find index of key to delete\r\n            LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);\r\n            int dpIndex = binarySearch(ln.dictionary, ln.numPairs, key);\r\n\r\n\r\n            if (dpIndex < 0) {\r\n\r\n                /* Flow of execution goes here when key is absent in B+ tree */\r\n\r\n                System.err.println(\"Invalid Delete: Key unable to be found.\");\r\n\r\n            } else {\r\n\r\n                // Successfully delete the dictionary pair\r\n                ln.delete(dpIndex, value);\r\n\r\n                // Check for deficiencies\r\n                if (ln.isDeficient()) {\r\n\r\n                    LeafNode sibling;\r\n                    InternalNode parent = ln.parent;\r\n\r\n                    // Borrow: First, check the left sibling, then the right sibling\r\n                    if (ln.leftSibling != null &&\r\n                            ln.leftSibling.parent == ln.parent &&\r\n                            ln.leftSibling.isLendable()) {\r\n\r\n                        sibling = ln.leftSibling;\r\n                        DictionaryPair borrowedDP = sibling.dictionary[sibling.numPairs - 1];\r\n\r\n\t\t\t\t\t\t/* Insert borrowed dictionary pair, sort dictionary,\r\n\t\t\t\t\t\t   and delete dictionary pair from sibling */\r\n                        ln.insert(borrowedDP);\r\n                        sortDictionary(ln.dictionary);\r\n                        sibling.delete(sibling.numPairs - 1);\r\n\r\n                        // Update key in parent if necessary\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n                        if (((Comparable)borrowedDP.key).compareTo(parent.keys[pointerIndex - 1]) < 0) {\r\n                            parent.keys[pointerIndex - 1] = ln.dictionary[0].key;\r\n                        }\r\n\r\n\r\n                    } else if (ln.rightSibling != null &&\r\n                            ln.rightSibling.parent == ln.parent &&\r\n                            ln.rightSibling.isLendable()) {\r\n\r\n                        sibling = ln.rightSibling;\r\n                        DictionaryPair borrowedDP = sibling.dictionary[0];\r\n\r\n\t\t\t\t\t\t/* Insert borrowed dictionary pair, sort dictionary,\r\n\t\t\t\t\t       and delete dictionary pair from sibling */\r\n                        ln.insert(borrowedDP);\r\n                        sibling.delete(0);\r\n                        sortDictionary(sibling.dictionary);\r\n\r\n                        // Update key in parent if necessary\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n                        if (((Comparable) borrowedDP.key).compareTo(parent.keys[pointerIndex]) >= 0) {\r\n                            parent.keys[pointerIndex] = sibling.dictionary[0].key;\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                    // Merge: First, check the left sibling, then the right sibling\r\n                    else if (ln.leftSibling != null &&\r\n                            ln.leftSibling.parent == ln.parent &&\r\n                            ln.leftSibling.isMergeable()) {\r\n\r\n                        sibling = ln.leftSibling;\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n\r\n                        // Remove key and child pointer from parent\r\n                        parent.removeKey(pointerIndex - 1);\r\n                        parent.removePointer(ln);\r\n\r\n                        // Update sibling pointer\r\n                        sibling.rightSibling = ln.rightSibling;\r\n\r\n                        // Check for deficiencies in parent\r\n                        if (parent.isDeficient()) {\r\n                            handleDeficiency(parent);\r\n                        }\r\n\r\n                    } else if (ln.rightSibling != null &&\r\n                            ln.rightSibling.parent == ln.parent &&\r\n                            ln.rightSibling.isMergeable()) {\r\n\r\n                        sibling = ln.rightSibling;\r\n                        int pointerIndex = findIndexOfPointer(parent.childPointers, ln);\r\n\r\n                        // Remove key and child pointer from parent\r\n                        parent.removeKey(pointerIndex);\r\n                        parent.removePointer(pointerIndex);\r\n\r\n                        // Update sibling pointer\r\n                        sibling.leftSibling = ln.leftSibling;\r\n                        if (sibling.leftSibling == null) {\r\n                            firstLeaf = sibling;\r\n                        }\r\n\r\n                        if (parent.isDeficient()) {\r\n                            handleDeficiency(parent);\r\n                        }\r\n                    }\r\n\r\n                } else if (this.root == null && this.firstLeaf.numPairs == 0) {\r\n\r\n\t\t\t\t\t/* Flow of execution goes here when the deleted dictionary\r\n\t\t\t\t\t   pair was the only pair within the tree */\r\n\r\n                    // Set first leaf as null to indicate B+ tree is empty\r\n                    this.firstLeaf = null;\r\n\r\n                } else {\r\n\r\n\t\t\t\t\t/* The dictionary of the LeafNode object may need to be\r\n\t\t\t\t\t   sorted after a successful delete */\r\n                    sortDictionary(ln.dictionary);\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given an integer key and floating point value, this method inserts a\r\n     * dictionary pair accordingly into the B+ tree.\r\n     * @param key: an integer key to be used in the dictionary pair\r\n     * @param value: a floating point number to be used in the dictionary pair\r\n     */\r\n    //    B+\r\n    // id age\r\n    // 1  20\r\n    // 2  50\r\n    // insert id =3 , age=60          // B+  key:60  , value:3      node( value , refrence)\r\n    // cluster\r\n    // btree.toString()\r\n\r\n    public void insert(Object key, Object value){\r\n        if (isEmpty()) {\r\n\r\n            /* Flow of execution goes here only when first insert takes place */\r\n\r\n            // Create leaf node as first node in B plus tree (root is null)\r\n            LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));\r\n\r\n            // Set as first leaf node (can be used later for in-order leaf traversal)\r\n            this.firstLeaf = ln;\r\n\r\n        } else {\r\n            // Find leaf node to insert into\r\n            LeafNode ln = (this.root == null) ? this.firstLeaf :\r\n                    findLeafNode(key);\r\n\r\n            // Insert into leaf node fails if node becomes overfull\r\n            if (!ln.insert(new DictionaryPair(key, value))) {\r\n\r\n                // Sort all the dictionary pairs with the included pair to be inserted\r\n                ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);\r\n                ln.numPairs++;\r\n                sortDictionary(ln.dictionary);\r\n\r\n                // Split the sorted pairs into two halves\r\n                int midpoint = getMidpoint();\r\n                DictionaryPair[] halfDict = splitDictionary(ln, midpoint);\r\n\r\n                if (ln.parent == null) {\r\n\r\n                    /* Flow of execution goes here when there is 1 node in tree */\r\n\r\n                    // Create internal node to serve as parent, use dictionary midpoint key\r\n                    Object[] parent_keys = new Object[this.m];\r\n                    parent_keys[0] = halfDict[0].key;\r\n                    InternalNode parent = new InternalNode(this.m, parent_keys);\r\n                    ln.parent = parent;\r\n                    parent.appendChildPointer(ln);\r\n\r\n                } else {\r\n\r\n                    /* Flow of execution goes here when parent exists */\r\n\r\n                    // Add new key to parent for proper indexing\r\n                    Object newParentKey = halfDict[0].key;\r\n                    ln.parent.keys[ln.parent.degree - 1] = newParentKey;\r\n                    Arrays.sort(ln.parent.keys, 0, ln.parent.degree);\r\n                }\r\n\r\n                // Create new LeafNode that holds the other half\r\n                LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);\r\n\r\n                // Update child pointers of parent node\r\n                int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;\r\n                ln.parent.insertChildPointer(newLeafNode, pointerIndex);\r\n\r\n                // Make leaf nodes siblings of one another\r\n                newLeafNode.rightSibling = ln.rightSibling;\r\n                if (newLeafNode.rightSibling != null) {\r\n                    newLeafNode.rightSibling.leftSibling = newLeafNode;\r\n                }\r\n                ln.rightSibling = newLeafNode;\r\n                newLeafNode.leftSibling = ln;\r\n\r\n                if (this.root == null) {\r\n\r\n                    // Set the root of B+ tree to be the parent\r\n                    this.root = ln.parent;\r\n\r\n                } else {\r\n\r\n\t\t\t\t\t/* If parent is overfull, repeat the process up the tree,\r\n\t\t\t   \t\t   until no deficiencies are found */\r\n                    InternalNode in = ln.parent;\r\n                    while (in != null) {\r\n                        if (in.isOverfull()) {\r\n                            splitInternalNode(in);\r\n                        } else {\r\n                            break;\r\n                        }\r\n                        in = in.parent;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a key, this method returns the value associated with the key\r\n     * within a dictionary pair that exists inside the B+ tree.\r\n     * @param key: the key to be searched within the B+ tree\r\n     * @return the floating point value associated with the key within the B+ tree\r\n     */\r\n    public Vector<Object> search(Object key) {\r\n\t\t// If B+ tree is completely empty, simply return null\r\n\t\tif (isEmpty()) { return null; }\r\n\r\n\t\t// Find leaf node that holds the dictionary key\r\n\t\tLeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);\r\n\r\n\t\t// Perform binary search to find index of key within dictionary\r\n\t\tDictionaryPair[] dps = ln.dictionary;\r\n\t\tint index = binarySearch(dps, ln.numPairs, key);\r\n\r\n\t\t// If index negative, the key doesn't exist in B+ tree\r\n\t\tif (index < 0) {\r\n\t\t\treturn null;\r\n\t\t} else {\r\n\t\t\treturn dps[index].values;\r\n\t\t}\r\n    }\r\n    /**\r\n     * This method traverses the doubly linked list of the B+ tree and records\r\n     * all values whose associated keys are within the range specified by\r\n     * lowerBound and upperBound.\r\n     * @param lowerBoun: (int) the lower bound of the range\r\n     * @param upperBoun: (int) the upper bound of the range\r\n     * @return an ArrayList<Double> that holds all values of dictionary pairs\r\n     * whose keys are within the specified range\r\n     */\r\n    public Vector<Object> search(Object lowerBoun, Object upperBoun) {\r\n\r\n        // Instantiate Double array to hold values\r\n        Vector<Object> values = new Vector<>();\r\n\r\n        Comparable<Object> lowerBound = (Comparable<Object>) lowerBoun;\r\n        Comparable<Object> upperBound = (Comparable<Object>) upperBoun;\r\n        // Iterate through the doubly linked list of leaves\r\n        LeafNode currNode = this.firstLeaf;\r\n        while (currNode != null) {\r\n\r\n            // Iterate through the dictionary of each node\r\n            DictionaryPair dps[] = currNode.dictionary;\r\n            for (DictionaryPair dp : dps) {\r\n\r\n\t\t\t\t/* Stop searching the dictionary once a null value is encountered\r\n\t\t\t\t   as this the indicates the end of non-null values */\r\n                if (dp == null) { break; }\r\n\r\n                // Include value if its key fits within the provided range\r\n                if (lowerBound.compareTo(dp.key) <= 0 && upperBound.compareTo(dp.key) >= 0) {\r\n                    values.addAll(dp.values);\r\n                }\r\n            }\r\n\r\n\t\t\t/* Update the current node to be the right sibling,\r\n\t\t\t   leaf traversal is from left to right */\r\n            currNode = currNode.rightSibling;\r\n\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    /**\r\n     * This class represents a general node within the B+ tree and serves as a\r\n     * superclass of InternalNode and LeafNode.\r\n     */\r\n    public class Node {\r\n        InternalNode parent;\r\n    }\r\n\r\n    /**\r\n     * This class represents the internal nodes within the B+ tree that traffic\r\n     * all search/insert/delete operations. An internal node only holds keys; it\r\n     * does not hold dictionary pairs.\r\n     */\r\n    private class InternalNode extends Node {\r\n        int maxDegree;\r\n        int minDegree;\r\n        int degree;\r\n        InternalNode leftSibling;\r\n        InternalNode rightSibling;\r\n        Object[] keys;\r\n        Node[] childPointers;\r\n\r\n        /**\r\n         * This method appends 'pointer' to the end of the childPointers\r\n         * instance variable of the InternalNode object. The pointer can point to\r\n         * an InternalNode object or a LeafNode object since the formal\r\n         * parameter specifies a Node object.\r\n         * @param pointer: Node pointer that is to be appended to the\r\n         *                    childPointers list\r\n         */\r\n        private void appendChildPointer(Node pointer) {\r\n            this.childPointers[degree] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * Given a Node pointer, this method will return the index of where the\r\n         * pointer lies within the childPointers instance variable. If the pointer\r\n         * can't be found, the method returns -1.\r\n         * @param pointer: a Node pointer that may lie within the childPointers\r\n         *                     instance variable\r\n         * @return the index of 'pointer' within childPointers, or -1 if\r\n         * 'pointer' can't be found\r\n         */\r\n        private int findIndexOfPointer(Node pointer) {\r\n            for (int i = 0; i < childPointers.length; i++) {\r\n                if (childPointers[i] == pointer) { return i; }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        /**\r\n         * Given a pointer to a Node object and an integer index, this method\r\n         * inserts the pointer at the specified index within the childPointers\r\n         * instance variable. As a result of the insert, some pointers may be\r\n         * shifted to the right of the index.\r\n         * @param pointer: the Node pointer to be inserted\r\n         * @param index: the index at which the insert is to take place\r\n         */\r\n        private void insertChildPointer(Node pointer, int index) {\r\n            for (int i = degree - 1; i >= index ;i--) {\r\n                childPointers[i + 1] = childPointers[i];\r\n            }\r\n            this.childPointers[index] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is deficient or not.\r\n         * An InternalNode is deficient when its current degree of children falls\r\n         * below the allowed minimum.\r\n         * @return a boolean indicating whether the InternalNode is deficient\r\n         * or not\r\n         */\r\n        private boolean isDeficient() {\r\n            return this.degree < this.minDegree;\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is capable of\r\n         * lending one of its dictionary pairs to a deficient node. An InternalNode\r\n         * can give away a dictionary pair if its current degree is above the\r\n         * specified minimum.\r\n         * @return a boolean indicating whether or not the InternalNode has\r\n         * enough dictionary pairs in order to give one away.\r\n         */\r\n        private boolean isLendable() { return this.degree > this.minDegree; }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is capable of being\r\n         * merged with. An InternalNode can be merged with if it has the minimum\r\n         * degree of children.\r\n         * @return a boolean indicating whether or not the InternalNode can be\r\n         * merged with\r\n         */\r\n        private boolean isMergeable() { return this.degree == this.minDegree; }\r\n\r\n        /**\r\n         * This simple method determines if the InternalNode is considered overfull,\r\n         * i.e. the InternalNode object's current degree is one more than the\r\n         * specified maximum.\r\n         * @return a boolean indicating if the InternalNode is overfull\r\n         */\r\n        private boolean isOverfull() {\r\n            return this.degree == maxDegree + 1;\r\n        }\r\n\r\n        /**\r\n         * Given a pointer to a Node object, this method inserts the pointer to\r\n         * the beginning of the childPointers instance variable.\r\n         * @param pointer: the Node object to be prepended within childPointers\r\n         */\r\n        private void prependChildPointer(Node pointer) {\r\n            for (int i = degree - 1; i >= 0 ;i--) {\r\n                childPointers[i + 1] = childPointers[i];\r\n            }\r\n            this.childPointers[0] = pointer;\r\n            this.degree++;\r\n        }\r\n\r\n        /**\r\n         * This method sets keys[index] to null. This method is used within the\r\n         * parent of a merging, deficient LeafNode.\r\n         * @param index: the location within keys to be set to null\r\n         */\r\n        private void removeKey(int index) { this.keys[index] = null;}\r\n\r\n        /**\r\n         * This method sets childPointers[index] to null and additionally\r\n         * decrements the current degree of the InternalNode.\r\n         * @param index: the location within childPointers to be set to null\r\n         */\r\n        private void removePointer(int index) {\r\n            this.childPointers[index] = null;\r\n            this.degree--;\r\n        }\r\n\r\n        /**\r\n         * This method removes 'pointer' from the childPointers instance\r\n         * variable and decrements the current degree of the InternalNode. The\r\n         * index where the pointer node was assigned is set to null.\r\n         * @param pointer: the Node pointer to be removed from childPointers\r\n         */\r\n        private void removePointer(Node pointer) {\r\n            for (int i = 0; i < childPointers.length; i++) {\r\n                if (childPointers[i] == pointer) { this.childPointers[i] = null; }\r\n            }\r\n            this.degree--;\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: the max degree of the InternalNode\r\n         * @param keys: the list of keys that InternalNode is initialized with\r\n         */\r\n        private InternalNode(int m, Object[] keys) {\r\n            this.maxDegree = m;\r\n            this.minDegree = (int)Math.ceil(m/2.0);\r\n            this.degree = 0;\r\n            this.keys = keys;\r\n            this.childPointers = new Node[this.maxDegree+1];\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: the max degree of the InternalNode\r\n         * @param keys: the list of keys that InternalNode is initialized with\r\n         * @param pointers: the list of pointers that InternalNode is initialized with\r\n         */\r\n        private InternalNode(int m, Object[] keys, Node[] pointers) {\r\n            this.maxDegree = m;\r\n            this.minDegree = (int)Math.ceil(m/2.0);\r\n            this.degree = linearNullSearch(pointers);\r\n            this.keys = keys;\r\n            this.childPointers = pointers;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class represents the leaf nodes within the B+ tree that hold\r\n     * dictionary pairs. The leaf node has no children. The leaf node has a\r\n     * minimum and maximum number of dictionary pairs it can hold, as specified\r\n     * by m, the max degree of the B+ tree. The leaf nodes form a doubly linked\r\n     * list that, i.e. each leaf node has a left and right sibling*/\r\n    public class LeafNode extends Node {\r\n        int maxNumPairs;\r\n        int minNumPairs;\r\n        int numPairs;\r\n        LeafNode leftSibling;\r\n        LeafNode rightSibling;\r\n        DictionaryPair[] dictionary;\r\n\r\n\r\n        // 2,3,5,1,7 -> // 1,2,3,5,7\r\n        // 1,2,3,4,5 -> // 1,2,3,4,5\r\n\r\n        /**\r\n         * Given an index, this method sets the dictionary pair at that index\r\n         * within the dictionary to null.\r\n         * @param index: the location within the dictionary to be set to null\r\n         */\r\n        public void delete(int index) {\r\n            // Delete dictionary pair from leaf\r\n            if(dictionary[index].values.isEmpty())\r\n                this.dictionary[index] = null;\r\n\r\n            // Decrement numPairs\r\n            numPairs--;\r\n        }\r\n        public void delete(int index, Object value) {\r\n\r\n            if(!dictionary[index].values.remove(value))\r\n                System.err.println(\"Value Not Found\");;\r\n            // Delete dictionary pair from leaf\r\n            if(dictionary[index].values.isEmpty())\r\n                this.dictionary[index] = null;\r\n\r\n            // Decrement numPairs\r\n            numPairs--;\r\n        }\r\n\r\n        /**\r\n         * This method attempts to insert a dictionary pair within the dictionary\r\n         * of the LeafNode object. If it succeeds, numPairs increments, the\r\n         * dictionary is sorted, and the boolean true is returned. If the method\r\n         * fails, the boolean false is returned.\r\n         * @param dp: the dictionary pair to be inserted\r\n         * @return a boolean indicating whether or not the insert was successful\r\n         */\r\n        ////////////// revisesssssssssssssssssssssssssssssss\r\n        public boolean insert(DictionaryPair dp) {\r\n            if (this.isFull()) {\r\n\r\n                /* Flow of execution goes here when numPairs == maxNumPairs */\r\n\r\n                return false;\r\n            } else {\r\n\r\n                // Insert dictionary pair, increment numPairs, sort dictionary\r\n                if(updateKeyVal(dp))\r\n                    return true;\r\n\r\n                this.dictionary[numPairs] = dp;\r\n                numPairs++;\r\n                Arrays.sort(this.dictionary, 0, numPairs);\r\n\r\n                return true;\r\n\r\n            }\r\n        }\r\n        private boolean updateKeyVal(DictionaryPair dp){\r\n            for (DictionaryPair dictionaryPair : dictionary) {\r\n                if (dictionaryPair.key.equals(dp.key)){\r\n                    dictionaryPair.values.add(dp.values.get(0));\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode is deficient, i.e.\r\n         * the numPairs within the LeafNode object is below minNumPairs.\r\n         * @return a boolean indicating whether or not the LeafNode is deficient\r\n         */\r\n        public boolean isDeficient() { return numPairs < minNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode is full, i.e. the\r\n         * numPairs within the LeafNode is equal to the maximum number of pairs.\r\n         * @return a boolean indicating whether or not the LeafNode is full\r\n         */\r\n        public boolean isFull() { return numPairs == maxNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode object is capable of\r\n         * lending a dictionary pair to a deficient leaf node. The LeafNode\r\n         * object can lend a dictionary pair if its numPairs is greater than\r\n         * the minimum number of pairs it can hold.\r\n         * @return a boolean indicating whether or not the LeafNode object can\r\n         * give a dictionary pair to a deficient leaf node\r\n         */\r\n        public boolean isLendable() { return numPairs > minNumPairs; }\r\n\r\n        /**\r\n         * This simple method determines if the LeafNode object is capable of\r\n         * being merged with, which occurs when the number of pairs within the\r\n         * LeafNode object is equal to the minimum number of pairs it can hold.\r\n         * @return a boolean indicating whether or not the LeafNode object can\r\n         * be merged with\r\n         */\r\n        public boolean isMergeable() {\r\n            return numPairs == minNumPairs;\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param m: order of B+ tree that is used to calculate maxNumPairs and\r\n         *           minNumPairs\r\n         * @param dp: first dictionary pair insert into new node\r\n         */\r\n        public LeafNode(int m, DictionaryPair dp) {\r\n            this.maxNumPairs = m - 1;\r\n            this.minNumPairs = (int)(Math.ceil(m/2) - 1);\r\n            this.dictionary = new DictionaryPair[m];\r\n            this.numPairs = 0;\r\n            this.insert(dp);\r\n        }\r\n\r\n        /**\r\n         * Constructor\r\n         * @param dps: list of DictionaryPair objects to be immediately inserted\r\n         *             into new LeafNode object\r\n         * @param m: order of B+ tree that is used to calculate maxNumPairs and\r\n         * \t\t     minNumPairs\r\n         * @param parent: parent of newly created child LeafNode\r\n         */\r\n        public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {\r\n            this.maxNumPairs = m - 1;\r\n            this.minNumPairs = (int)(Math.ceil(m/2) - 1);\r\n            this.dictionary = dps;\r\n            this.numPairs = linearNullSearch(dps);\r\n            this.parent = parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class represents a dictionary pair that is to be contained within the\r\n     * leaf nodes of the B+ tree. The class implements the Comparable interface\r\n     * so that the DictionaryPair objects can be sorted later on.\r\n     */\r\n    public class DictionaryPair implements Comparable<DictionaryPair> {\r\n        Object key;\r\n//        Object value;\r\n        Vector<Object> values = new Vector<>();\r\n//        ArrayList<Object> values;\r\n        // 20 -----> {1, 6, 7 ,2}\r\n        /**\r\n         * Constructor\r\n         * @param key: the key of the key-value pair\r\n         * @param value: the value of the key-value pair\r\n         */\r\n        public DictionaryPair(Object key, Object value) {\r\n            this.key = key;\r\n            values.add(value);\r\n        }\r\n\r\n        /**\r\n         * This is a method that allows comparisons to take place between\r\n         * DictionaryPair objects in order to sort them later on\r\n         * @param o\r\n         * @return\r\n         */\r\n        @Override\r\n        public int compareTo(DictionaryPair o) {\r\n            if (key.equals(o.key)) {\r\n                return 0;\r\n            } else if (key instanceof Integer && o.key instanceof Integer) {\r\n                return Integer.compare((Integer) key, (Integer) o.key);\r\n            } else if (key instanceof String && o.key instanceof String) {\r\n                return ((String) key).compareTo((String) o.key);\r\n            } else if (key instanceof Double && o.key instanceof Double) {\r\n                return Double.compare((Double) key, (Double) o.key);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Keys must be of the same type and comparable\");\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder treeString = new StringBuilder();\r\n        appendNodeToString(root, treeString, 0);\r\n        return treeString.toString();\r\n    }\r\n\r\n    private void appendNodeToString(Node node, StringBuilder treeString, int level) {\r\n        if (node instanceof LeafNode) {\r\n            appendLeafNodeToString((LeafNode) node, treeString, level);\r\n        } else if (node instanceof InternalNode) {\r\n            appendInternalNodeToString((InternalNode) node, treeString, level);\r\n        }\r\n    }\r\n\r\n    private void appendLeafNodeToString(LeafNode leafNode, StringBuilder treeString, int level) {\r\n        treeString.append(\"Leaf Node (Level \").append(level).append(\"): \");\r\n        for (int i = 0; i < leafNode.numPairs; i++) {\r\n            DictionaryPair pair = leafNode.dictionary[i];\r\n            treeString.append(\"(\").append(pair.key).append(\", \").append(pair.value).append(\") \");\r\n        }\r\n        treeString.append(\"\\n\");\r\n    }\r\n\r\n    private void appendInternalNodeToString(InternalNode internalNode, StringBuilder treeString, int level) {\r\n        treeString.append(\"Internal Node (Level \").append(level).append(\"): \");\r\n        for (int i = 0; i < internalNode.degree - 1; i++) {\r\n            treeString.append(internalNode.keys[i]).append(\" \");\r\n        }\r\n        treeString.append(\"\\n\");\r\n\r\n        for (int i = 0; i < internalNode.degree; i++) {\r\n            appendNodeToString(internalNode.childPointers[i], treeString, level + 1);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // Ensure correct number of arguments\r\n//\t\tif (args.length != 1) {\r\n//\t\t\tSystem.err.println(\"usage: java bplustree <file_name>\");\r\n//\t\t\tSystem.exit(-1);\r\n//\t\t}\r\n\r\n        // Read from file\r\n//\t\tString fileName = args[0];\r\n        try {\r\n\r\n\r\n            // Prepare to read input file\r\n//\t\t\tFile file = new File(System.getProperty(\"user.dir\") + \"/\" + fileName);\r\n//\t\t\tScanner sc = new Scanner(file);\r\n\r\n            // Create output file in which search results will be stored\r\n//\t\t\tFileWriter logger = new FileWriter(\"output_file.txt\", false);\r\n//\t\t\tboolean firstLine = true;\r\n\r\n            // Create initial B+ tree\r\n            BPlusIndex bpt = new BPlusIndex(3,\"\",\"\",\"\");\r\n            bpt.insert(\"Ahmed\",\"Ahmed\");\r\n            bpt.insert(\"JJ\",\"PlaceofJJ\");\r\n            System.out.println(bpt.search(\"Ahmed\"));\r\n//\t\t\tbpt.insert(\"JJ\",\"PlaceofJJ2\");\r\n//            bpt.delete(\"JJ\");\r\n            System.out.println(bpt.search(\"JJ\"));\r\n            bpt.insert(\"R\",\"placeofR\");\r\n            System.out.println(bpt.search(\"R\"));\r\n            bpt.insert(\"Banana\",\"PlaceofBanana\");\r\n//            System.out.println(bpt.search(\"Ahmed\",\"R\"));\r\n\r\n//\t\t\tbpt.insert(21,\"PlaceofInt\");\r\n//\t\t\tSystem.out.println(bpt.search(21));\r\n//\r\n//\t\t\tbpt.insert(2.5,\"PlaceofDouble\");\r\n//\t\t\tSystem.out.println(bpt.search(2.5));\r\n\r\n\r\n\r\n            // Perform an operation for each line in the input file\r\n//\t\t\twhile (sc.hasNextLine()) {\r\n//\t\t\t\tString line = sc.nextLine().replace(\" \", \"\");\r\n//\t\t\t\tString[] tokens = line.split(\"[(,)]\");\r\n//\r\n//\t\t\t\tswitch (tokens[0]) {\r\n//\r\n//\t\t\t\t\t// Initializes an m-order B+ tree\r\n//\t\t\t\t\tcase \"Initialize\":\r\n//\t\t\t\t\t\tbpt = new bplustree(Integer.parseInt(tokens[1]));\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Insert a dictionary pair into the B+ tree\r\n//\t\t\t\t\tcase \"Insert\":\r\n//\t\t\t\t\t\tbpt.insert(tokens[1], tokens[2]);\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Delete a dictionary pair from the B+ tree\r\n//\t\t\t\t\tcase \"Delete\":\r\n//\t\t\t\t\t\tbpt.delete(tokens[1]);\r\n//\t\t\t\t\t\tbreak;\r\n//\r\n//\t\t\t\t\t// Perform a search or search operation on the B+ tree\r\n//\t\t\t\t\tcase \"Search\":\r\n//\t\t\t\t\t\tString result = \"\";\r\n//\r\n//\t\t\t\t\t\t// Perform search (across a range) operation\r\n//\t\t\t\t\t\tif (tokens.length == 3) {\r\n//\t\t\t\t\t\t\tArrayList<String> values = bpt.search(\r\n//\t\t\t\t\t\t\t\t\t\t\ttokens[1],\r\n//\t\t\t\t\t\t\t\t\t\t\ttokens[2]);\r\n//\r\n//\t\t\t\t\t\t\t// Record search result as a String\r\n//\t\t\t\t\t\t\tif (values.size() != 0) {\r\n//\t\t\t\t\t\t\t\tfor (String v : values) { result += v + \", \"; }\r\n//\t\t\t\t\t\t\t\tresult = result.substring(0, result.length() - 2);\r\n//\t\t\t\t\t\t\t} else {\r\n//\t\t\t\t\t\t\t\tresult = \"Null\";\r\n//\t\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// Perform search operation\r\n//\t\t\t\t\t\telse {\r\n//\r\n//\t\t\t\t\t\t\t/* Perform search for key, if resulting value is\r\n//\t\t\t\t\t\t\t   null, then the key could not be found */\r\n//\t\t\t\t\t\t\tString value = bpt.search(tokens[1]);\r\n//\t\t\t\t\t\t\tresult = (value == null) ? \"Null\" :\r\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue;\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// Output search result in .txt file\r\n//\t\t\t\t\t\tif (firstLine) {\r\n//\t\t\t\t\t\t\tlogger.write(result);\r\n//\t\t\t\t\t\t\tfirstLine = false;\r\n//\t\t\t\t\t\t} else {\r\n//\t\t\t\t\t\t\tlogger.write(\"\\n\" + result);\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\tlogger.flush();\r\n//\r\n//\t\t\t\t\t\tbreak;\r\n//\t\t\t\t\tdefault:\r\n//\t\t\t\t\t\tthrow new IllegalArgumentException(\"\\\"\" + tokens[0] +\r\n//\t\t\t\t\t\t\t\t\"\\\"\" + \" is an unacceptable input.\");\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\r\n            // Close output file\r\n//\t\t\tlogger.close();\r\n\r\n//\t\t} catch (FileNotFoundException e) {\r\n//\t\t\tSystem.err.println(e);\r\n        } catch (IllegalArgumentException e) {\r\n            System.err.println(e);\r\n//\t\t} catch (IOException e) {\r\n//\t\t\tSystem.err.println(e);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Data/Index/BPlusIndex.java b/Data/Index/BPlusIndex.java
--- a/Data/Index/BPlusIndex.java	(revision 08bf60ee029e4d27e11f9f4e95037884603bb369)
+++ b/Data/Index/BPlusIndex.java	(date 1710531522766)
@@ -1133,7 +1133,7 @@
         treeString.append("Leaf Node (Level ").append(level).append("): ");
         for (int i = 0; i < leafNode.numPairs; i++) {
             DictionaryPair pair = leafNode.dictionary[i];
-            treeString.append("(").append(pair.key).append(", ").append(pair.value).append(") ");
+            treeString.append("(").append(pair.key).append(", ").append(pair.values).append(") ");
         }
         treeString.append("\n");
     }
